<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: A C++ library for single-cell data analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A C++ library for single-cell data analysis </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md__github_workspace_README"></a> <img src="https://github.com/LTLA/libscran/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/LTLA/libscran/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/></p>
<h1>Overview</h1>
<p >The <b>libscran</b> library takes core parts of the <a href="https://github.com/MarioniLab/scran"><b>scran</b></a> Bioconductor package (as well as other useful bits from other packages) and implements them in C++. The idea is to provide a light-weight library that can be easily embedded into other applications without including the entire R/Bioconductor runtime. For example, we can compile <a href="https://github.com/jkanche/scran.js"><b>libscran</b> to WebAssembly</a> to perform single-cell analyses in the browser; or we can wrap <a href="https://github.com/LTLA/scran.chan"><b>libscran</b> into an R package</a> for a minimal-dependency version of the basic Bioconductor single-cell analysis stack. The library itself is compatible with any CMake-based build system and can be turned into a fully header-only library for easy deployment.</p>
<h1>Quick start</h1>
<p >The example below demonstrates how to use <b>libscran</b> to run a standard analysis of single-cell RNA-seq data.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;scran/scran.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Loading the data from an (unzipped) MatrixMarket file.</span></div>
<div class="line"><span class="keyword">auto</span> mat = tatami::MatrixMarket::load_sparse_matrix(path);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Filtering out low-quality cells. </span></div>
<div class="line"><span class="keyword">auto</span> qc_res = <a class="code hl_class" href="classscran_1_1PerCellQCMetrics.html">scran::PerCellQCMetrics</a>().<a class="code hl_function" href="classscran_1_1PerCellQCMetrics.html#aedc028b2d8df9b5b28623599e060796e">run</a>(mat.get(), { <span class="comment">/* mito subset definitions go here */</span> });</div>
<div class="line"><span class="keyword">auto</span> qc_filters = <a class="code hl_class" href="classscran_1_1PerCellQCFilters.html">scran::PerCellQCFilters</a>().<a class="code hl_function" href="classscran_1_1PerCellQCFilters.html#a01c8cd43b53e8e2469d3ed4116ac4eec">run</a>(qc_res);</div>
<div class="line"><span class="keyword">auto</span> filtered = <a class="code hl_class" href="classscran_1_1FilterCells.html">scran::FilterCells</a>().<a class="code hl_function" href="classscran_1_1FilterCells.html#a5dd2a40d99238d32c20bd069dff7faff">run</a>(mat, qc_filters.overall_filter.data());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computing log-normalized expression values, re-using the total count from the QC step.</span></div>
<div class="line"><span class="keyword">auto</span> size_factors = scran::subset_vector&lt;false&gt;(qc_res.sums, qc_filters.overall_filter.data());</div>
<div class="line"><span class="keyword">auto</span> normalized = <a class="code hl_class" href="classscran_1_1LogNormCounts.html">scran::LogNormCounts</a>().<a class="code hl_function" href="classscran_1_1LogNormCounts.html#adff2220b45c6931d41883290524f4aca">run</a>(filtered, std::move(size_factors));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Identifying highly variable genes from the residuals from the first (and only) batch.</span></div>
<div class="line"><span class="keyword">auto</span> var_res = <a class="code hl_class" href="classscran_1_1ModelGeneVar.html">scran::ModelGeneVar</a>().<a class="code hl_function" href="classscran_1_1ModelGeneVar.html#a1175b286f29951889b512ed332dd36bf">run</a>(normalized.get());</div>
<div class="line"><span class="keyword">auto</span> keep = <a class="code hl_class" href="classscran_1_1ChooseHVGs.html">scran::ChooseHVGs</a>().<a class="code hl_function" href="classscran_1_1ChooseHVGs.html#a8485437ec27c1b9d167fd00b38dad235">run</a>(var_res.residuals[0].size(), var_res.residuals[0].data());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Performing a PCA on the HVGs. We transpose the output so cells are columns again.</span></div>
<div class="line"><span class="keywordtype">int</span> npcs = 20;</div>
<div class="line"><span class="keyword">auto</span> pca_res = <a class="code hl_class" href="classscran_1_1RunPCA.html">scran::RunPCA</a>().<a class="code hl_function" href="classscran_1_1RunPCA.html#a736079c03235fca4ec6bfd7b99b0f565">set_rank</a>(npcs).run(normalized.get(), keep.data());</div>
<div class="line">pca_res.pcs.adjointInPlace();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Performing clustering.</span></div>
<div class="line"><span class="keyword">auto</span> clust_res = <a class="code hl_class" href="classscran_1_1ClusterSNNGraphMultiLevel.html">scran::ClusterSNNGraphMultiLevel</a>().<a class="code hl_function" href="classscran_1_1ClusterSNNGraphMultiLevel.html#aee656f0e8b2adce118a2ae16375735a5">run</a>(npcs, pca_res.pcs.cols(), pca_res.pcs.data());</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; best_clustering = clust_res.<a class="code hl_variable" href="structscran_1_1ClusterSNNGraphMultiLevel_1_1Results.html#a27434f77a03c488270b68c08e5105e80">membership</a>[clust_res.max];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Throw in some marker detection.</span></div>
<div class="line"><span class="keyword">auto</span> marker_res = <a class="code hl_class" href="classscran_1_1ScoreMarkers.html">scran::ScoreMarkers</a>().<a class="code hl_function" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run</a>(normalized.get(), best_clustering.data());</div>
<div class="ttc" id="aclassscran_1_1ChooseHVGs_html"><div class="ttname"><a href="classscran_1_1ChooseHVGs.html">scran::ChooseHVGs</a></div><div class="ttdoc">Choose highly variable genes for downstream analyses.</div><div class="ttdef"><b>Definition:</b> ChooseHVGs.hpp:23</div></div>
<div class="ttc" id="aclassscran_1_1ChooseHVGs_html_a8485437ec27c1b9d167fd00b38dad235"><div class="ttname"><a href="classscran_1_1ChooseHVGs.html#a8485437ec27c1b9d167fd00b38dad235">scran::ChooseHVGs::run</a></div><div class="ttdeci">void run(size_t n, const V *statistic, T *output) const</div><div class="ttdef"><b>Definition:</b> ChooseHVGs.hpp:65</div></div>
<div class="ttc" id="aclassscran_1_1ClusterSNNGraphMultiLevel_html"><div class="ttname"><a href="classscran_1_1ClusterSNNGraphMultiLevel.html">scran::ClusterSNNGraphMultiLevel</a></div><div class="ttdoc">Multi-level clustering on a shared nearest-neighbor graph.</div><div class="ttdef"><b>Definition:</b> ClusterSNNGraph.hpp:128</div></div>
<div class="ttc" id="aclassscran_1_1ClusterSNNGraphMultiLevel_html_aee656f0e8b2adce118a2ae16375735a5"><div class="ttname"><a href="classscran_1_1ClusterSNNGraphMultiLevel.html#aee656f0e8b2adce118a2ae16375735a5">scran::ClusterSNNGraphMultiLevel::run</a></div><div class="ttdeci">Results run(size_t ndims, size_t ncells, const double *mat)</div><div class="ttdef"><b>Definition:</b> ClusterSNNGraph.hpp:246</div></div>
<div class="ttc" id="aclassscran_1_1FilterCells_html"><div class="ttname"><a href="classscran_1_1FilterCells.html">scran::FilterCells</a></div><div class="ttdoc">Filter out low-quality cells.</div><div class="ttdef"><b>Definition:</b> FilterCells.hpp:23</div></div>
<div class="ttc" id="aclassscran_1_1FilterCells_html_a5dd2a40d99238d32c20bd069dff7faff"><div class="ttname"><a href="classscran_1_1FilterCells.html#a5dd2a40d99238d32c20bd069dff7faff">scran::FilterCells::run</a></div><div class="ttdeci">std::shared_ptr&lt; MAT &gt; run(std::shared_ptr&lt; MAT &gt; mat, const X *filter)</div><div class="ttdef"><b>Definition:</b> FilterCells.hpp:61</div></div>
<div class="ttc" id="aclassscran_1_1LogNormCounts_html"><div class="ttname"><a href="classscran_1_1LogNormCounts.html">scran::LogNormCounts</a></div><div class="ttdoc">Compute log-normalized expression values.</div><div class="ttdef"><b>Definition:</b> LogNormCounts.hpp:31</div></div>
<div class="ttc" id="aclassscran_1_1LogNormCounts_html_adff2220b45c6931d41883290524f4aca"><div class="ttname"><a href="classscran_1_1LogNormCounts.html#adff2220b45c6931d41883290524f4aca">scran::LogNormCounts::run</a></div><div class="ttdeci">std::shared_ptr&lt; MAT &gt; run(std::shared_ptr&lt; MAT &gt; mat, V size_factors)</div><div class="ttdef"><b>Definition:</b> LogNormCounts.hpp:88</div></div>
<div class="ttc" id="aclassscran_1_1ModelGeneVar_html"><div class="ttname"><a href="classscran_1_1ModelGeneVar.html">scran::ModelGeneVar</a></div><div class="ttdoc">Compute and model the per-gene variances in log-expression data.</div><div class="ttdef"><b>Definition:</b> ModelGeneVar.hpp:32</div></div>
<div class="ttc" id="aclassscran_1_1ModelGeneVar_html_a1175b286f29951889b512ed332dd36bf"><div class="ttname"><a href="classscran_1_1ModelGeneVar.html#a1175b286f29951889b512ed332dd36bf">scran::ModelGeneVar::run</a></div><div class="ttdeci">void run(const MAT *mat, Stat *means, Stat *variances, Stat *fitted, Stat *residuals)</div><div class="ttdef"><b>Definition:</b> ModelGeneVar.hpp:74</div></div>
<div class="ttc" id="aclassscran_1_1PerCellQCFilters_html"><div class="ttname"><a href="classscran_1_1PerCellQCFilters.html">scran::PerCellQCFilters</a></div><div class="ttdoc">Create filters to identify low-quality cells.</div><div class="ttdef"><b>Definition:</b> PerCellQCFilters.hpp:38</div></div>
<div class="ttc" id="aclassscran_1_1PerCellQCFilters_html_a01c8cd43b53e8e2469d3ed4116ac4eec"><div class="ttname"><a href="classscran_1_1PerCellQCFilters.html#a01c8cd43b53e8e2469d3ed4116ac4eec">scran::PerCellQCFilters::run</a></div><div class="ttdeci">Thresholds run(size_t ncells, const S *sums, const D *detected, std::vector&lt; PPTR &gt; subset_proportions, X *filter_by_sums, X *filter_by_detected, std::vector&lt; X * &gt; filter_by_subset_proportions, X *overall_filter)</div><div class="ttdef"><b>Definition:</b> PerCellQCFilters.hpp:113</div></div>
<div class="ttc" id="aclassscran_1_1PerCellQCMetrics_html"><div class="ttname"><a href="classscran_1_1PerCellQCMetrics.html">scran::PerCellQCMetrics</a></div><div class="ttdoc">Compute typical per-cell quality control metrics.</div><div class="ttdef"><b>Definition:</b> PerCellQCMetrics.hpp:33</div></div>
<div class="ttc" id="aclassscran_1_1PerCellQCMetrics_html_aedc028b2d8df9b5b28623599e060796e"><div class="ttname"><a href="classscran_1_1PerCellQCMetrics.html#aedc028b2d8df9b5b28623599e060796e">scran::PerCellQCMetrics::run</a></div><div class="ttdeci">Results run(const MAT *mat, std::vector&lt; SUB &gt; subsets)</div><div class="ttdef"><b>Definition:</b> PerCellQCMetrics.hpp:85</div></div>
<div class="ttc" id="aclassscran_1_1RunPCA_html"><div class="ttname"><a href="classscran_1_1RunPCA.html">scran::RunPCA</a></div><div class="ttdoc">Perform PCA on a gene-cell matrix.</div><div class="ttdef"><b>Definition:</b> RunPCA.hpp:33</div></div>
<div class="ttc" id="aclassscran_1_1RunPCA_html_a736079c03235fca4ec6bfd7b99b0f565"><div class="ttname"><a href="classscran_1_1RunPCA.html#a736079c03235fca4ec6bfd7b99b0f565">scran::RunPCA::set_rank</a></div><div class="ttdeci">RunPCA &amp; set_rank(int r=Defaults::rank)</div><div class="ttdef"><b>Definition:</b> RunPCA.hpp:68</div></div>
<div class="ttc" id="aclassscran_1_1ScoreMarkers_html"><div class="ttname"><a href="classscran_1_1ScoreMarkers.html">scran::ScoreMarkers</a></div><div class="ttdoc">Score each gene as a candidate marker for each group of cells.</div><div class="ttdef"><b>Definition:</b> ScoreMarkers.hpp:120</div></div>
<div class="ttc" id="aclassscran_1_1ScoreMarkers_html_afbd8272701d34277064610f6ad9dd90b"><div class="ttname"><a href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">scran::ScoreMarkers::run</a></div><div class="ttdeci">void run(const Matrix *p, const G *group, std::vector&lt; Stat * &gt; means, std::vector&lt; Stat * &gt; detected, std::vector&lt; std::vector&lt; Stat * &gt; &gt; cohen, std::vector&lt; std::vector&lt; Stat * &gt; &gt; auc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; lfc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; delta_detected)</div><div class="ttdef"><b>Definition:</b> ScoreMarkers.hpp:471</div></div>
<div class="ttc" id="astructscran_1_1ClusterSNNGraphMultiLevel_1_1Results_html_a27434f77a03c488270b68c08e5105e80"><div class="ttname"><a href="structscran_1_1ClusterSNNGraphMultiLevel_1_1Results.html#a27434f77a03c488270b68c08e5105e80">scran::ClusterSNNGraphMultiLevel::Results::membership</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; membership</div><div class="ttdef"><b>Definition:</b> ClusterSNNGraph.hpp:226</div></div>
</div><!-- fragment --><p >Each class represents a step in the analysis and has tunable parameters, e.g., <code>RunPCA::set_rank</code> to set the number of PCs. See the <a href="https://ltla.github.io/libscran/">reference documentation</a> for more details.</p>
<h1>Available functions</h1>
<p >Most of the functions are motivated by the theory in the <a href="https://bioconductor.org/books/release/OSCA/"><b>Orchestrating single-cell analysis with Bioconductor</b> book</a>.</p>
<p ><b>Identification and filtering of low-quality cells</b> are performed using an outlier-based approach. The <code>PerCellQCMetrics</code> class will compute common QC metrics, the <code>PerCellQCFilters</code> class will identify filtering thresholds from the distribution of such metrics, and the <code>FilterCells</code> class will apply those filters to the count matrix.</p>
<p ><b>Log-transformed normalized expression values</b> are computed from the count matrix, using size factors derived from the library size. This is performed using the <code>LogNormCounts</code> class.</p>
<p ><b>Variance modelling and selection of highly variable genes</b> is performed on the log-expression values. The <code>ModelGeneVar</code> class will fit a mean-dependent trend to the variances across genes, while the <code>ChooseHVGs</code> class will choose the top set of HVGs based on the residuals from the trend.</p>
<p ><b>Principal component analysis</b> is used to compress and denoise the data based on the first few PCs. The <code>RunPCA</code> class will use an approximate PCA algorithm to efficiently compute the top PCs from the HVG-subsetted matrix. Alternatively, the <code>BlockedPCA</code> and <code>MultiBatchPCA</code> classes can be used when dealing with multiple batches.</p>
<p ><b>Clustering of cells</b> is performed with various algorithms. The simplest of these is k-means clustering using the Hartigan-Wong algorithm, via <code>ClusterKmeans</code>. We also provide several flavors of graph-based clustering from a shared-nearest neighbor graph, using community detection algorithms such as multi-level (<code>ClusterSNNGraphMultiLevel</code>), Leiden (<code>ClusterSNNGraphLeiden</code>) or Walktrap clustering (<code>ClusterSNNGraphWalktrap</code>).</p>
<p ><b>Per-cluster marker detection</b> is performed based on pairwise comparisons between clusters. The <code>ScoreMarkers</code> class will aggregate the set of pairwise comparisons into a single suite of summary statistics for each cluster. Users can then rank by a statistic of interest to obtain a marker listing for each cluster.</p>
<p >The output of PCA is also directly compatible with <a href="https://github.com/LTLA/umappp">UMAP</a> and <a href="https://github.com/LTLA/qdtsne">t-SNE</a> C++ implementations. Readers are referred to the documentation for those libraries for more details.</p>
<h1>Example analysis</h1>
<p >Compile the <a href="https://github.com/LTLA/libscran/blob/master/gallery/minimal.cpp"><code>minimal.cpp</code></a> example by running the following commands at the root of the <b>libscran</b> directory:</p>
<div class="fragment"><div class="line">cmake -S . -B example -DBUILD_TESTING=OFF -DBUILD_GALLERY=ON</div>
<div class="line">cmake --build example --target minimal</div>
</div><!-- fragment --><p >Download and decompress a Matrix Market file containing a scRNA-seq count matrix:</p>
<div class="fragment"><div class="line">mkdir example/data</div>
<div class="line">wget https://cf.10xgenomics.com/samples/cell-exp/2.1.0/pbmc4k/pbmc4k_filtered_gene_bc_matrices.tar.gz -P example/data</div>
<div class="line">tar -xvf example/data/pbmc4k_filtered_gene_bc_matrices.tar.gz --directory example/data</div>
</div><!-- fragment --><p >Run the minimal pipeline:</p>
<div class="fragment"><div class="line">time example/gallery/minimal example/data/filtered_gene_bc_matrices/GRCh38/matrix.mtx</div>
<div class="line"> </div>
<div class="line">## Detected 10 clusters in &#39;example/data/filtered_gene_bc_matrices/GRCh38/matrix.mtx&#39;</div>
<div class="line">## </div>
<div class="line">## real 0m2.340s</div>
<div class="line">## user 0m9.613s</div>
<div class="line">## sys  0m0.104s</div>
</div><!-- fragment --><h1>Building projects</h1>
<p >If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  libscran</div>
<div class="line">  GIT_REPOSITORY https://github.com/LTLA/libscran</div>
<div class="line">  GIT_TAG master # or any version of interest </div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(libscran)</div>
</div><!-- fragment --><p >Then you can link to <b>libscran</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe libscran)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE libscran)</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
