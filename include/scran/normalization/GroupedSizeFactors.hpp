#ifndef SCRAN_CLUSTERED_SIZE_FACTORS_HPP
#define SCRAN_CLUSTERED_SIZE_FACTORS_HPP

#include "MedianSizeFactors.hpp"
#include "../aggregation/AggregateAcrossCells.hpp"

#include "tatami/base/DenseMatrix.hpp"
#include "tatami/ext/ArrayView.hpp"
#include "tatami/stats/sums.hpp"

#include <memory>
#include <vector>
#include <algorithm>

/**
 * @file GroupedSizeFactors.hpp
 *
 * @brief Compute size factors for groups of cells.
 */

namespace scran {

/**
 * @brief Compute grouped size factors to handle composition bias.
 *
 * This implements the grouping approach described in Lun et al. (2016) whereby groups/clusters of cells are used to construct pseudo-cells.
 * These pseudo-cells are normalized against each other using median-based size factors (see `MedianSizeFactors`) to obtain group-specific scaling factors.
 * Each cell is then normalized against its pseudo-cell using the library size; each cell's size factor is defined as product of its library size-based factor and the median-based factor for its group.
 *
 * This strategy leverages the reduced sparsity of the pseudo-cells to obtain sensible median-based size factors for removing composition biases,
 * while still generating per-cell factors for computing a normalized single-cell expression matrix in `LogNormCounts`.
 * The assumption is that there are no composition biases within each group; thus, the supplied groupings should correspond to subpopulations in the data, typically generated by clustering.
 *
 * @see
 * Lun ATL, Bach K and Marioni JC (2016).
 * Pooling across cells to normalize single-cell RNA sequencing data with many zero counts.
 * _Genome Biol._ 17:75
 */
class GroupedSizeFactors {
public:
    /**
     * @brief Default parameter settings.
     */
    struct Defaults {
        /** 
         * See `set_center()` for more details.
         */
        static constexpr bool center = true;
    };

    /**
     * @param c Whether to center the size factors to have a mean of unity.
     * This is usually desirable for interpretation of relative values.
     * 
     * @return A reference to this `MedianSizeFactors` object.
     *
     * For more control over centering, this can be set to `false` and the resulting size factors can be passed to `CenterSizeFactors`.
     */
    GroupedSizeFactors& set_center(bool c = Defaults::center) {
        center = c;
        return *this;
    }

private:
    bool center = Defaults::center;

public:
    /**
     * Compute per-cell size factors based on user-supplied groupings.
     *
     * @tparam T Numeric data type of the input matrix.
     * @tparam IDX Integer index type of the input matrix.
     * @tparam Group Integer type for the groupings.
     * @tparam Out Numeric data type of the output vector.
     *
     * @param mat Matrix containing non-negative expression data, usually counts.
     * Rows should be genes and columns should be cells.
     * @param[in] group Pointer to an array of group identifiers, of length equal to the number of columns in `mat`.
     * Values should be integers in \f$[0, N)\f$ where \f$N\f$ is the total number of groups.
     * @param[out] output Pointer to an array to use to store the output size factors.
     * This should be of length equal to the number of columns in `mat`.
     *
     * @return `output` is filled with the size factors for all cells in `mat`.
     */
    template<typename T, typename IDX, typename Group, typename Out>
    void run(const tatami::Matrix<T, IDX>* mat, const Group* group, Out* output) {
        size_t NR = mat->nrow(), NC = mat->ncol();
        if (!NC) {
            return;
        }

        // Aggregating each group to get a pseudo-bulk sample.
        auto ngroups = *std::max_element(group, group + NC) + 1;
        std::vector<double> combined(ngroups * NR);
        {
            std::vector<double*> sums(ngroups);
            for (size_t i = 0; i < ngroups; ++i) {
                sums[i] = combined.data() + i * NR;
            }
            AggregateAcrossCells aggregator;
            aggregator.run(mat, group, std::move(sums), std::vector<int*>());
        }

        // Choosing one of them to be the reference. Here, we borrow some logic
        // from edgeR and use the one with the largest sum of square roots,
        // which provides a compromise between transcriptome coverage and
        // complexity. The root ensures that we don't pick a sample that just
        // has very high expression in a small subset of genes, while still
        // remaining responsive to the overall coverage level.
        size_t ref = 0;
        double best = 0;

        for (size_t i = 0; i < ngroups; ++i) {
            auto start = combined.data() + i * NR;
            double current = 0;
            for (size_t j = 0; j < NR; ++j) {
                current += std::sqrt(start[j]);
            }
            if (current > best) {
                ref = i;
            }
        }

        // Computing median-based size factors.
        tatami::ArrayView view(combined.data(), combined.size());
        tatami::DenseColumnMatrix<T, IDX, decltype(view)> aggmat(NR, ngroups, std::move(view));
        MedianSizeFactors med;
        auto mres = med.run(&aggmat, combined.data() + ref * NR);

        // Propagating to each cell via library size-based normalization.
        auto aggcolsums = tatami::column_sums(&aggmat);
        auto colsums = tatami::column_sums(mat);
        for (size_t i = 0; i < NC; ++i) {
            auto curgroup = group[i];
            auto scale = static_cast<double>(colsums[i])/static_cast<double>(aggcolsums[curgroup]);
            output[i] = scale * mres.factors[curgroup];
        }

        // Throwing in some centering.
        if (center) {
            CenterSizeFactors centerer;
            centerer.run(NC, output);
        }
    }

public:
    /**
     * @brief Result of the size factor calculations.
     * @tparam Out Numeric type for the size factors.
     */
    template<typename Out>
    struct Results {
        /**
         * @cond
         */
        Result(size_t NC) : factors(NC) {}
        /**
         * @endcond
         */

        /**
         * Vector of length equal to the number of cells,
         * containing the size factor for each cell.
         */
        std::vector<Out> factors;
    };

    /**
     * Compute per-cell size factors based on user-supplied groupings.
     *
     * @tparam T Numeric data type of the input matrix.
     * @tparam IDX Integer index type of the input matrix.
     * @tparam Group Integer type for the groupings.
     *
     * @param mat Matrix containing non-negative expression data, usually counts.
     * Rows should be genes and columns should be cells.
     * @param[in] group Pointer to an array of group identifiers, of length equal to the number of columns in `mat`.
     * Values should be integers in \f$[0, N)\f$ where \f$N\f$ is the total number of groups.
     *
     * @return A `Results` object is returned containing the size factors.
     */
    template<typename Out = double, typename T, typename IDX, typename Group>
    Results<Out> run(const tatami::Matrix<T, IDX>* mat, const Group* group) {
        Result<Out> output(mat->ncol());
        run(mat, group, output.factors.data());
        return output;
    }
};

}

#endif
