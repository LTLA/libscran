<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions for single-cell RNA-seq analyses.  
<a href="namespacescran.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacescran_1_1differential__analysis"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescran_1_1differential__analysis.html">differential_analysis</a></td></tr>
<tr class="memdesc:namespacescran_1_1differential__analysis"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for differential analysis. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacescran_1_1igraph"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescran_1_1igraph.html">igraph</a></td></tr>
<tr class="memdesc:namespacescran_1_1igraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for working with <b>igraph</b> in <b>libscran</b>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate expression values across cells.  <a href="classscran_1_1AggregateAcrossCells.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a shared nearest-neighbor graph with cells as nodes.  <a href="classscran_1_1BuildSnnGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1CenterSizeFactors.html">CenterSizeFactors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center size factors prior to scaling normalization.  <a href="classscran_1_1CenterSizeFactors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ChooseHvgs.html">ChooseHvgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose highly variable genes for downstream analyses.  <a href="classscran_1_1ChooseHvgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ChooseOutlierFilters.html">ChooseOutlierFilters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define outlier filters from the median and MAD.  <a href="structscran_1_1ChooseOutlierFilters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ChoosePseudoCount.html">ChoosePseudoCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose a pseudo-count for log-transformation.  <a href="classscran_1_1ChoosePseudoCount.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ClusterSnnGraphLeiden.html">ClusterSnnGraphLeiden</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leiden clustering on a shared nearest-neighbor graph.  <a href="classscran_1_1ClusterSnnGraphLeiden.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ClusterSnnGraphMultiLevel.html">ClusterSnnGraphMultiLevel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-level clustering on a shared nearest-neighbor graph.  <a href="classscran_1_1ClusterSnnGraphMultiLevel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ClusterSnnGraphWalktrap.html">ClusterSnnGraphWalktrap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walktrap clustering on a shared nearest-neighbor graph.  <a href="classscran_1_1ClusterSnnGraphWalktrap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ComputeMedianMad.html">ComputeMedianMad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median and MAD from an array of values.  <a href="classscran_1_1ComputeMedianMad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsample a dataset based on its neighbors.  <a href="classscran_1_1DownsampleByNeighbors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1FilterCells.html">FilterCells</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter out low-quality cells.  <a href="classscran_1_1FilterCells.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1FitVarianceTrend.html">FitVarianceTrend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a mean-variance trend to log-count data.  <a href="classscran_1_1FitVarianceTrend.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1GroupedSizeFactors.html">GroupedSizeFactors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute grouped size factors to handle composition bias.  <a href="classscran_1_1GroupedSizeFactors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1HypergeometricTail.html">HypergeometricTail</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute hypergeometric tail probabilities.  <a href="classscran_1_1HypergeometricTail.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute log-normalized expression values.  <a href="classscran_1_1LogNormCounts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute median-based size factors to handle composition bias.  <a href="classscran_1_1MedianSizeFactors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ModelGeneVariances.html">ModelGeneVariances</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and model the per-gene variances in log-expression data.  <a href="classscran_1_1ModelGeneVariances.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute PCA after adjusting for differences between batch sizes.  <a href="classscran_1_1MultiBatchPca.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute pairwise effect size between groups of cells.  <a href="classscran_1_1PairwiseEffects.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcMetrics.html">PerCellAdtQcMetrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-cell quality control metrics from an ADT count matrix.  <a href="classscran_1_1PerCellAdtQcMetrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellCrisprQcMetrics.html">PerCellCrisprQcMetrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-cell quality control metrics from a CRISPR guide count matrix.  <a href="classscran_1_1PerCellCrisprQcMetrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQcMetrics.html">PerCellQcMetrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a variety of per-cell quality control metrics from a count matrix.  <a href="classscran_1_1PerCellQcMetrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellRnaQcMetrics.html">PerCellRnaQcMetrics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute typical per-cell quality control metrics from an RNA count matrix.  <a href="classscran_1_1PerCellRnaQcMetrics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ResidualPca.html">ResidualPca</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute PCA after regressing out an uninteresting factor.  <a href="classscran_1_1ResidualPca.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale multi-modal embeddings to adjust for differences in variance.  <a href="classscran_1_1ScaleByNeighbors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per-cell scores for a given feature set.  <a href="classscran_1_1ScoreFeatureSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Score each gene as a candidate marker for each group of cells.  <a href="classscran_1_1ScoreMarkers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1SimplePca.html">SimplePca</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a simple PCA on a gene-cell matrix.  <a href="classscran_1_1SimplePca.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1SuggestAdtQcFilters.html">SuggestAdtQcFilters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create filters to identify low-quality cells from ADT-derived QC metrics.  <a href="classscran_1_1SuggestAdtQcFilters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1SuggestCrisprQcFilters.html">SuggestCrisprQcFilters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create filters to identify low-quality cells from CRISPR-derived QC metrics.  <a href="classscran_1_1SuggestCrisprQcFilters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1SuggestRnaQcFilters.html">SuggestRnaQcFilters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create filters to identify low-quality cells from RNA-derived QC metrics.  <a href="classscran_1_1SuggestRnaQcFilters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1SummarizeEffects.html">SummarizeEffects</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summarize pairwise effects into summary statistics per group.  <a href="classscran_1_1SummarizeEffects.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1VariableBlockWeightParameters.html">VariableBlockWeightParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for <code><a class="el" href="namespacescran.html#a128f43444ef77988f27ae5b91cef6b13">variable_block_weight()</a></code>.  <a href="structscran_1_1VariableBlockWeightParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abcd041d625290609e221552910ae2c34"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescran.html#abcd041d625290609e221552910ae2c34">WeightPolicy</a> : char { <b>NONE</b>
, <b>VARIABLE</b>
, <b>EQUAL</b>
 }</td></tr>
<tr class="separator:abcd041d625290609e221552910ae2c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ef15c373235b0265a64091521a23b90"><td class="memTemplParams" colspan="2">template&lt;bool check_nan_ = true, typename Stat_ , typename Output_ &gt; </td></tr>
<tr class="memitem:a9ef15c373235b0265a64091521a23b90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a9ef15c373235b0265a64091521a23b90">average_vectors</a> (size_t n, std::vector&lt; Stat_ * &gt; in, Output_ *out)</td></tr>
<tr class="separator:a9ef15c373235b0265a64091521a23b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529f9eba1f60395f143e0e1be6478aa0"><td class="memTemplParams" colspan="2">template&lt;bool check_nan_ = true, typename Output_  = double, typename Stat_ &gt; </td></tr>
<tr class="memitem:a529f9eba1f60395f143e0e1be6478aa0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a529f9eba1f60395f143e0e1be6478aa0">average_vectors</a> (size_t n, std::vector&lt; Stat_ * &gt; in)</td></tr>
<tr class="separator:a529f9eba1f60395f143e0e1be6478aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90170f1fa4f0968c88bf2293b0428494"><td class="memTemplParams" colspan="2">template&lt;bool check_nan_ = true, typename Stat_ , typename Weight_ , typename Output_ &gt; </td></tr>
<tr class="memitem:a90170f1fa4f0968c88bf2293b0428494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a90170f1fa4f0968c88bf2293b0428494">average_vectors_weighted</a> (size_t n, std::vector&lt; Stat_ * &gt; in, const Weight_ *w, Output_ *out)</td></tr>
<tr class="separator:a90170f1fa4f0968c88bf2293b0428494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d954de2d068e866197831608c5c84"><td class="memTemplParams" colspan="2">template&lt;bool check_nan_ = true, typename Output_  = double, typename Stat_ , typename Weight_ &gt; </td></tr>
<tr class="memitem:a5d7d954de2d068e866197831608c5c84"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a5d7d954de2d068e866197831608c5c84">average_vectors_weighted</a> (size_t n, std::vector&lt; Stat_ * &gt; in, const Weight_ *w)</td></tr>
<tr class="separator:a5d7d954de2d068e866197831608c5c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d993d00e1fa75ce3f4864cc2999c321"><td class="memTemplParams" colspan="2">template&lt;typename Id_ &gt; </td></tr>
<tr class="memitem:a2d993d00e1fa75ce3f4864cc2999c321"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a2d993d00e1fa75ce3f4864cc2999c321">count_ids</a> (size_t length, const Id_ *ids)</td></tr>
<tr class="separator:a2d993d00e1fa75ce3f4864cc2999c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442c2327430d3e4c425beebfe4dcd768"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = int, bool allow_zeros_ = false, typename Id_ &gt; </td></tr>
<tr class="memitem:a442c2327430d3e4c425beebfe4dcd768"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a442c2327430d3e4c425beebfe4dcd768">tabulate_ids</a> (size_t length, const Id_ *ids, bool allow_zeros=false)</td></tr>
<tr class="separator:a442c2327430d3e4c425beebfe4dcd768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128f43444ef77988f27ae5b91cef6b13"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescran.html#a128f43444ef77988f27ae5b91cef6b13">variable_block_weight</a> (double s, const <a class="el" href="structscran_1_1VariableBlockWeightParameters.html">VariableBlockWeightParameters</a> &amp;params)</td></tr>
<tr class="separator:a128f43444ef77988f27ae5b91cef6b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ec43b74a91a73bd539472d265af8ff"><td class="memTemplParams" colspan="2">template&lt;typename Size_ &gt; </td></tr>
<tr class="memitem:a92ec43b74a91a73bd539472d265af8ff"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a92ec43b74a91a73bd539472d265af8ff">compute_block_weights</a> (const std::vector&lt; Size_ &gt; &amp;sizes, <a class="el" href="namespacescran.html#abcd041d625290609e221552910ae2c34">WeightPolicy</a> policy, const <a class="el" href="structscran_1_1VariableBlockWeightParameters.html">VariableBlockWeightParameters</a> &amp;param)</td></tr>
<tr class="separator:a92ec43b74a91a73bd539472d265af8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57dae3ada8336a1bfa01ac8daa9fc11"><td class="memTemplParams" colspan="2">template&lt;bool retain, class Vector , typename Subset &gt; </td></tr>
<tr class="memitem:af57dae3ada8336a1bfa01ac8daa9fc11"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#af57dae3ada8336a1bfa01ac8daa9fc11">subset_vector</a> (const Vector &amp;vec, const Subset *sub)</td></tr>
<tr class="separator:af57dae3ada8336a1bfa01ac8daa9fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4600cde1ede42175b03490d96949524"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4600cde1ede42175b03490d96949524"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#ab4600cde1ede42175b03490d96949524">vector_to_pointers</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;input)</td></tr>
<tr class="separator:ab4600cde1ede42175b03490d96949524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab779e5059834ccb43c97f536ba26a4ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab779e5059834ccb43c97f536ba26a4ab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#ab779e5059834ccb43c97f536ba26a4ab">vector_to_pointers</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;input)</td></tr>
<tr class="separator:ab779e5059834ccb43c97f536ba26a4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701fa9241011d6c4aa5ea84e33ee62ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a701fa9241011d6c4aa5ea84e33ee62ce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran.html#a701fa9241011d6c4aa5ea84e33ee62ce">vector_to_pointers</a> (std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;input)</td></tr>
<tr class="separator:a701fa9241011d6c4aa5ea84e33ee62ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for single-cell RNA-seq analyses. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abcd041d625290609e221552910ae2c34" name="abcd041d625290609e221552910ae2c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd041d625290609e221552910ae2c34">&#9670;&#160;</a></span>WeightPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacescran.html#abcd041d625290609e221552910ae2c34">scran::WeightPolicy</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Policy to use for weighting blocks based on their size, i.e., the number of cells in each block. This controls the calculation of weighted averages across blocks.</p>
<ul>
<li><code>NONE</code>: no weighting is performed. Larger blocks will contribute more to the weighted average.</li>
<li><code>EQUAL</code>: each block receives equal weight, regardless of its size. Equivalent to averaging across blocks without weights.</li>
<li><code>VARIABLE</code>: each batch is weighted using the logic in <code><a class="el" href="namespacescran.html#a128f43444ef77988f27ae5b91cef6b13">variable_block_weight()</a></code>. This penalizes small blocks with unreliable statistics while equally weighting all large blocks. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9ef15c373235b0265a64091521a23b90" name="a9ef15c373235b0265a64091521a23b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef15c373235b0265a64091521a23b90">&#9670;&#160;</a></span>average_vectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool check_nan_ = true, typename Stat_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::average_vectors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Average parallel elements across multiple arrays.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">check_nan_</td><td>Whether to check for NaNs. If <code>true</code>, NaNs are ignored in the average calculations for each element, at the cost of some efficiency. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Type of the input statistic, typically floating point. </td></tr>
    <tr><td class="paramname">Output_</td><td>Floating-point output type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of length <code>n</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to an output array of length <code>n</code>. On completion, <code>out</code> is filled with the average of all arrays in <code>in</code>. Specifically, each element of <code>out</code> is set to the average of the corresponding elements across all <code>in</code> arrays. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a529f9eba1f60395f143e0e1be6478aa0" name="a529f9eba1f60395f143e0e1be6478aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529f9eba1f60395f143e0e1be6478aa0">&#9670;&#160;</a></span>average_vectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool check_nan_ = true, typename Output_  = double, typename Stat_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; scran::average_vectors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Average parallel elements across multiple arrays.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">check_nan_</td><td>Whether to check for NaNs, see <code><a class="el" href="namespacescran.html#a9ef15c373235b0265a64091521a23b90">average_vectors()</a></code>. </td></tr>
    <tr><td class="paramname">Output</td><td>Floating-point output type. </td></tr>
    <tr><td class="paramname">Stat</td><td>Type of the input statistic, typically floating point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of length <code>n</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length <code>n</code> is returned, containing the average of all arrays in <code>in</code>. </dd></dl>

</div>
</div>
<a id="a90170f1fa4f0968c88bf2293b0428494" name="a90170f1fa4f0968c88bf2293b0428494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90170f1fa4f0968c88bf2293b0428494">&#9670;&#160;</a></span>average_vectors_weighted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool check_nan_ = true, typename Stat_ , typename Weight_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::average_vectors_weighted </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Weight_ *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a weighted average of parallel elements across multiple arrays.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">check_nan_</td><td>Whether to check for NaNs. If <code>true</code>, NaNs are ignored in the average calculations for each element, at the cost of some efficiency. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Type of the input statistic, typically floating point. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Type of the weight, typically floating point. </td></tr>
    <tr><td class="paramname">Output_</td><td>Floating-point output type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of length <code>n</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Pointer to an array of length equal to <code>in.size()</code>, containing the weight to use for each input array. Weights should be non-negative and finite. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>Pointer to an output array of length <code>n</code>. On output, <code>out</code> is filled with the weighted average of all arrays in <code>in</code>. Specifically, each element of <code>out</code> is set to the weighted average of the corresponding elements across all <code>in</code> arrays. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d7d954de2d068e866197831608c5c84" name="a5d7d954de2d068e866197831608c5c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7d954de2d068e866197831608c5c84">&#9670;&#160;</a></span>average_vectors_weighted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool check_nan_ = true, typename Output_  = double, typename Stat_ , typename Weight_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; scran::average_vectors_weighted </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat_ * &gt;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Weight_ *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a weighted average of parallel elements across multiple arrays.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">check_nan_</td><td>Whether to check for NaNs, see <code><a class="el" href="namespacescran.html#a90170f1fa4f0968c88bf2293b0428494">average_vectors_weighted()</a></code> for details. </td></tr>
    <tr><td class="paramname">Output_</td><td>Floating-point output type. </td></tr>
    <tr><td class="paramname">Weight_</td><td>Type of the weight, typically floating point. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Type of the input statistic, typically floating point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Length of each array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Vector of pointers to input arrays of the same length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>Pointer to an array of length equal to <code>in.size()</code>, containing the weight to use for each input array. Weights should be non-negative and finite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector is returned containing with the average of all arrays in <code>in</code>. </dd></dl>

</div>
</div>
<a id="a2d993d00e1fa75ce3f4864cc2999c321" name="a2d993d00e1fa75ce3f4864cc2999c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d993d00e1fa75ce3f4864cc2999c321">&#9670;&#160;</a></span>count_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Id_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t scran::count_ids </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *&#160;</td>
          <td class="paramname"><em>ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of unique 0-based IDs, e.g., for block or group assignments. All IDs are assumed to be integers in <code>[0, x)</code> where <code>x</code> is the return value of this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Id_</td><td>Integer type for the IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the array in <code>ids</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>Pointer to an array containing 0-based IDs of some kind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of IDs, or 0 if <code>length = 0</code>. </dd></dl>

</div>
</div>
<a id="a442c2327430d3e4c425beebfe4dcd768" name="a442c2327430d3e4c425beebfe4dcd768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442c2327430d3e4c425beebfe4dcd768">&#9670;&#160;</a></span>tabulate_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = int, bool allow_zeros_ = false, typename Id_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; scran::tabulate_ids </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Id_ *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_zeros</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the frequency of 0-based IDs, e.g., for block or group assignments. All IDs are assumed to be integers in <code>[0, x)</code> where <code>x</code> is the number of unique IDs.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Numeric type for the output frequencies. </td></tr>
    <tr><td class="paramname">Id_</td><td>Integer type for the IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the array in <code>ids</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ids</td><td>Pointer to an array containing 0-based IDs of some kind. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_zeros</td><td>Whether to throw an error if frequencies of zero are detected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length equal to the number of IDs, containing the frequency of each ID. An error is raised if an ID has zero frequency and <code>allow_zeros = false</code>. </dd></dl>

</div>
</div>
<a id="a128f43444ef77988f27ae5b91cef6b13" name="a128f43444ef77988f27ae5b91cef6b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128f43444ef77988f27ae5b91cef6b13">&#9670;&#160;</a></span>variable_block_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double scran::variable_block_weight </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1VariableBlockWeightParameters.html">VariableBlockWeightParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Weight each block of cells for use in computing a weighted average across blocks. The weight for each block is calcualted from the size of that block.</p>
<ul>
<li>If the block is empty smaller than some lower bound, it has zero weight.</li>
<li>If the block is greater than some upper bound, it has weight of 1.</li>
<li>Otherwise, the block has weight proportional to its size, increasing linearly from 0 to 1 between the two bounds.</li>
</ul>
<p>Blocks that are "large enough" are considered to be equally trustworthy and receive the same weight, ensuring that each block contributes equally to the weighted average. By comparison, very small blocks receive lower weight as their statistics are generally less stable. If both <code>cap</code> and <code>block_size</code> are zero, the weight is also set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Size of the block, in terms of the number of cells in that block. </td></tr>
    <tr><td class="paramname">params</td><td>Parameters for the weight calculation, consisting of the lower and upper bounds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Weight of the block, to use for computing a weighted average across blocks. </dd></dl>

</div>
</div>
<a id="a92ec43b74a91a73bd539472d265af8ff" name="a92ec43b74a91a73bd539472d265af8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ec43b74a91a73bd539472d265af8ff">&#9670;&#160;</a></span>compute_block_weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Size_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; scran::compute_block_weights </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Size_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacescran.html#abcd041d625290609e221552910ae2c34">WeightPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1VariableBlockWeightParameters.html">VariableBlockWeightParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute block weights for multiple blocks based on their size and the weighting policy. For variable weights, this function will call <code><a class="el" href="namespacescran.html#a128f43444ef77988f27ae5b91cef6b13">variable_block_weight()</a></code> for each block.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size_</td><td>Numeric type for the block size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>Vector of block sizes. </td></tr>
    <tr><td class="paramname">policy</td><td>Policy for weighting blocks of different sizes. </td></tr>
    <tr><td class="paramname">param</td><td>Parameters for the variable block weights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of block weights. </dd></dl>

</div>
</div>
<a id="af57dae3ada8336a1bfa01ac8daa9fc11" name="af57dae3ada8336a1bfa01ac8daa9fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57dae3ada8336a1bfa01ac8daa9fc11">&#9670;&#160;</a></span>subset_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool retain, class Vector , typename Subset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector scran::subset_vector </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Subset *&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subset a vector to retain/discard elements.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">retain</td><td>Should the non-zero elements in <code>sub</code> be retained (<code>true</code>) or discarded (<code>false</code>)? </td></tr>
    <tr><td class="paramname">Vector</td><td>A vector class that has a <code>size()</code> method, a <code>[]</code> operator, and a constructor that initializes the vector to a specified length. </td></tr>
    <tr><td class="paramname">Subset</td><td>Integer/boolean type for the subsetting vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector of arbitrary (copy-able) elements. </td></tr>
    <tr><td class="paramname">sub</td><td>Pointer to an array of integer/boolean elements of length equal to <code>vec</code>. Non-zero values indicate that an element should be retained (if <code>retain=true</code>) or discarded (otherwise).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector containing the desired subset of elements in <code>vec</code>. </dd></dl>

</div>
</div>
<a id="ab4600cde1ede42175b03490d96949524" name="ab4600cde1ede42175b03490d96949524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4600cde1ede42175b03490d96949524">&#9670;&#160;</a></span>vector_to_pointers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T * &gt; scran::vector_to_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a vector of pointers from a vector of vectors. This is a convenient utility as many <b>scran</b> functions accept the former but can return the latter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Vector of vector of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to each inner vector in <code>input</code>. </dd></dl>

</div>
</div>
<a id="ab779e5059834ccb43c97f536ba26a4ab" name="ab779e5059834ccb43c97f536ba26a4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab779e5059834ccb43c97f536ba26a4ab">&#9670;&#160;</a></span>vector_to_pointers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const T * &gt; scran::vector_to_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a vector of <code>const</code> pointers from a vector of vectors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Vector of vector of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to each inner vector in <code>input</code>. </dd></dl>

</div>
</div>
<a id="a701fa9241011d6c4aa5ea84e33ee62ce" name="a701fa9241011d6c4aa5ea84e33ee62ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701fa9241011d6c4aa5ea84e33ee62ce">&#9670;&#160;</a></span>vector_to_pointers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T * &gt; &gt; scran::vector_to_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a vector of vector of pointers from a vector of vectors of vectors..</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Vector of vector of vector of values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of vector of pointers to each inner vector in <code>input</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
