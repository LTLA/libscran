<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::quick_grouped_size_factors Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="namespacescran_1_1quick__grouped__size__factors.html">quick_grouped_size_factors</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran::quick_grouped_size_factors Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Quickly compute grouped size factors.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html" title="Options for run().">Options</a> for <code><a class="el" href="#ad169f5f470588ce24b98d38b8a28cab0">run()</a></code>.  <a href="structscran_1_1quick__grouped__size__factors_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad169f5f470588ce24b98d38b8a28cab0" id="r_ad169f5f470588ce24b98d38b8a28cab0"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename OutputFactor_ , typename Block_ , typename SizeFactor_ &gt; </td></tr>
<tr class="memitem:ad169f5f470588ce24b98d38b8a28cab0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad169f5f470588ce24b98d38b8a28cab0">run</a> (const tatami::Matrix&lt; Value_, Index_ &gt; *mat, OutputFactor_ *output, const <a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html">Options</a>&lt; Block_, SizeFactor_ &gt; &amp;opt)</td></tr>
<tr class="separator:ad169f5f470588ce24b98d38b8a28cab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d54d34f66804cdd575a15afed51a31" id="r_ad4d54d34f66804cdd575a15afed51a31"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename OutputFactor_ &gt; </td></tr>
<tr class="memitem:ad4d54d34f66804cdd575a15afed51a31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4d54d34f66804cdd575a15afed51a31">run</a> (const tatami::Matrix&lt; Value_, Index_ &gt; *mat, OutputFactor_ *output)</td></tr>
<tr class="separator:ad4d54d34f66804cdd575a15afed51a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1a64b8000babc387db62ad4eac0e5b" id="r_aab1a64b8000babc387db62ad4eac0e5b"><td class="memTemplParams" colspan="2">template&lt;typename OutputFactor_  = double, typename Value_ , typename Index_ , typename Block_ , typename SizeFactor_ &gt; </td></tr>
<tr class="memitem:aab1a64b8000babc387db62ad4eac0e5b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; OutputFactor_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab1a64b8000babc387db62ad4eac0e5b">run</a> (const tatami::Matrix&lt; Value_, Index_ &gt; *mat, const <a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html">Options</a>&lt; Block_, SizeFactor_ &gt; &amp;opt)</td></tr>
<tr class="separator:aab1a64b8000babc387db62ad4eac0e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe9fbd4babb71f00de1dbed648328e1" id="r_a6fe9fbd4babb71f00de1dbed648328e1"><td class="memTemplParams" colspan="2">template&lt;typename OutputFactor_  = double, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a6fe9fbd4babb71f00de1dbed648328e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; OutputFactor_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fe9fbd4babb71f00de1dbed648328e1">run</a> (const tatami::Matrix&lt; Value_, Index_ &gt; *mat)</td></tr>
<tr class="separator:a6fe9fbd4babb71f00de1dbed648328e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Quickly compute grouped size factors. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad169f5f470588ce24b98d38b8a28cab0" name="ad169f5f470588ce24b98d38b8a28cab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad169f5f470588ce24b98d38b8a28cab0">&#9670;&#160;</a></span>run() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename OutputFactor_ , typename Block_ , typename SizeFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::quick_grouped_size_factors::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputFactor_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html">Options</a>&lt; Block_, SizeFactor_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Quickly compute grouped size factors by deriving a sensible grouping from an expression matrix. The idea is to break up the dataset into broad clusters so that <code><a class="el" href="classscran_1_1GroupedSizeFactors.html" title="Compute grouped size factors to handle composition bias.">GroupedSizeFactors</a></code> can remove the composition biases between them. It is primarily intended for ADT count data where large composition biases are introduced by the presence of a few highly abundant markers in each subpopulation.</p>
<p>More specifically, this function will create an initial log-normalized matrix via <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code>, derive a low-dimensional representation via principal components analysis with <code><a class="el" href="classscran_1_1SimplePca.html" title="Perform a simple PCA on a gene-cell matrix.">SimplePca</a></code>, generate k-means clusters from the top principal components with the <b>kmeans</b> library, and finally use those clusters in <code><a class="el" href="classscran_1_1GroupedSizeFactors.html" title="Compute grouped size factors to handle composition bias.">GroupedSizeFactors</a></code>.</p>
<p>If multiple blocks are present, dimensionality reduction and clustering is performed separately for each block. This avoids wasting the cluster partitions on irrelevant differences between blocks, e.g., due to batch effects. However, the final calculation of grouped size factors will be done using the entire dataset at once, so the factors will remove block-to-block scaling differences.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the matrix row/column indices. </td></tr>
    <tr><td class="paramname">OutputFactor_</td><td>Floating-point ype of the output factors. </td></tr>
    <tr><td class="paramname">Block_</td><td>See <code><a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html" title="Options for run().">Options</a></code>. </td></tr>
    <tr><td class="paramname">SizeFactor_</td><td>See <code><a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html" title="Options for run().">Options</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Input count matrix, where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length equal to the number of cells. On output, this stores the output factors for each cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opt</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4d54d34f66804cdd575a15afed51a31" name="ad4d54d34f66804cdd575a15afed51a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d54d34f66804cdd575a15afed51a31">&#9670;&#160;</a></span>run() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename OutputFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::quick_grouped_size_factors::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputFactor_ *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ad169f5f470588ce24b98d38b8a28cab0">run()</a></code> with default options.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the matrix row/column indices. </td></tr>
    <tr><td class="paramname">OutputFactor_</td><td>Floating-point ype of the output factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Input count matrix, where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length equal to the number of cells. On output, this stores the output factors for each cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab1a64b8000babc387db62ad4eac0e5b" name="aab1a64b8000babc387db62ad4eac0e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1a64b8000babc387db62ad4eac0e5b">&#9670;&#160;</a></span>run() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputFactor_  = double, typename Value_ , typename Index_ , typename Block_ , typename SizeFactor_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; OutputFactor_ &gt; scran::quick_grouped_size_factors::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html">Options</a>&lt; Block_, SizeFactor_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ad169f5f470588ce24b98d38b8a28cab0">run()</a></code> that handles the memory allocation of the output factors.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputFactor_</td><td>Floating-point ype of the output factors. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the matrix row/column indices. </td></tr>
    <tr><td class="paramname">Block_</td><td>See <code><a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html" title="Options for run().">Options</a></code>. </td></tr>
    <tr><td class="paramname">SizeFactor_</td><td>See <code><a class="el" href="structscran_1_1quick__grouped__size__factors_1_1Options.html" title="Options for run().">Options</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Input count matrix, where rows are features and columns are cells. </td></tr>
    <tr><td class="paramname">opt</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length equal to the number of cells, containing the output factors for each cell. </dd></dl>

</div>
</div>
<a id="a6fe9fbd4babb71f00de1dbed648328e1" name="a6fe9fbd4babb71f00de1dbed648328e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe9fbd4babb71f00de1dbed648328e1">&#9670;&#160;</a></span>run() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputFactor_  = double, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; OutputFactor_ &gt; scran::quick_grouped_size_factors::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Value_, Index_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ad169f5f470588ce24b98d38b8a28cab0">run()</a></code> with default options.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputFactor_</td><td>Floating-point ype of the output factors. </td></tr>
    <tr><td class="paramname">Value_</td><td>Numeric type for the matrix values. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type of the matrix row/column indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Input count matrix, where rows are features and columns are cells.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length equal to the number of cells, containing the output factors for each cell. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
