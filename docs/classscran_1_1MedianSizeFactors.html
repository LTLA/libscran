<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::MedianSizeFactors Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1MedianSizeFactors-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::MedianSizeFactors Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Compute median-based size factors to handle composition bias.  
 <a href="classscran_1_1MedianSizeFactors.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MedianSizeFactors_8hpp_source.html">MedianSizeFactors.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1MedianSizeFactors_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1MedianSizeFactors_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1MedianSizeFactors_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of the size factor calculation.  <a href="structscran_1_1MedianSizeFactors_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa819da1b38830a8849bdf4cdd89b1994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html#aa819da1b38830a8849bdf4cdd89b1994">set_center</a> (bool c=<a class="el" href="structscran_1_1MedianSizeFactors_1_1Defaults.html#af747d883c33f4793ce28b9aade2d2ad6">Defaults::center</a>)</td></tr>
<tr class="separator:aa819da1b38830a8849bdf4cdd89b1994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5507419988ca1925e8f60bdc99436e51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html#a5507419988ca1925e8f60bdc99436e51">set_prior_count</a> (double p=<a class="el" href="structscran_1_1MedianSizeFactors_1_1Defaults.html#a909251588d34d41237a64df1dd85552c">Defaults::prior_count</a>)</td></tr>
<tr class="separator:a5507419988ca1925e8f60bdc99436e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8440bf543257fe771a5db35b0e4a9bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html#a8440bf543257fe771a5db35b0e4a9bbf">set_num_threads</a> (int n=<a class="el" href="structscran_1_1MedianSizeFactors_1_1Defaults.html#a175bd521275c0babb11e548885761700">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a8440bf543257fe771a5db35b0e4a9bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cc850dee0fe3462e3986434832fd48"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , typename Ref , typename Out &gt; </td></tr>
<tr class="memitem:a14cc850dee0fe3462e3986434832fd48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html#a14cc850dee0fe3462e3986434832fd48">run</a> (const tatami::Matrix&lt; T, IDX &gt; *mat, const Ref *ref, Out *output) const</td></tr>
<tr class="separator:a14cc850dee0fe3462e3986434832fd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fad66012a50b1ad4eec6bc954c3c14b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , typename Out &gt; </td></tr>
<tr class="memitem:a1fad66012a50b1ad4eec6bc954c3c14b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html#a1fad66012a50b1ad4eec6bc954c3c14b">run_with_mean</a> (const tatami::Matrix&lt; T, IDX &gt; *mat, Out *output) const</td></tr>
<tr class="separator:a1fad66012a50b1ad4eec6bc954c3c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07388a3bbfdbc6a023b6479b2012c6df"><td class="memTemplParams" colspan="2">template&lt;typename Out  = double, typename T , typename IDX , typename Ref &gt; </td></tr>
<tr class="memitem:a07388a3bbfdbc6a023b6479b2012c6df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1MedianSizeFactors_1_1Results.html">Results</a>&lt; Out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html#a07388a3bbfdbc6a023b6479b2012c6df">run</a> (const tatami::Matrix&lt; T, IDX &gt; *mat, const Ref *ref) const</td></tr>
<tr class="separator:a07388a3bbfdbc6a023b6479b2012c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae3787cccfaf98bba4d473856582893"><td class="memTemplParams" colspan="2">template&lt;typename Out  = double, typename T , typename IDX &gt; </td></tr>
<tr class="memitem:a1ae3787cccfaf98bba4d473856582893"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1MedianSizeFactors_1_1Results.html">Results</a>&lt; Out &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1MedianSizeFactors.html#a1ae3787cccfaf98bba4d473856582893">run_with_mean</a> (const tatami::Matrix&lt; T, IDX &gt; *mat) const</td></tr>
<tr class="separator:a1ae3787cccfaf98bba4d473856582893"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Compute median-based size factors to handle composition bias. </p>
<p >This is roughly equivalent to the DESeq2-based approach where the size factor for each library is defined as the median ratio against a reference profile. The aim is to account for composition biases from differential expression between libraries, which would not be handled properly by library size normalization. The main differences from DESeq2 are:</p>
<ul>
<li>The row means are used as the default reference, instead of the geometric mean. This avoids problems with reference values of zero in sparse data.</li>
<li>The median-based size factors are slightly shrunk towards the library size-derived factors. This ensures that the reported factors are never zero.</li>
</ul>
<p >In practice, this tends to work poorly for actual single-cell data due to its sparsity. Nonetheless, we provide it here because it can be helpful for removing composition biases between clusters. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a07388a3bbfdbc6a023b6479b2012c6df" name="a07388a3bbfdbc6a023b6479b2012c6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07388a3bbfdbc6a023b6479b2012c6df">&#9670;&#160;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out  = double, typename T , typename IDX , typename Ref &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1MedianSizeFactors_1_1Results.html">Results</a>&lt; Out &gt; scran::MedianSizeFactors::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref *&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute per-cell size factors against a user-supplied reference profile.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Out</td><td>Numeric type for the size factors. </td></tr>
    <tr><td class="paramname">T</td><td>Numeric data type of the input matrix. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer index type of the input matrix. </td></tr>
    <tr><td class="paramname">Ref</td><td>Numeric data type of the reference profile.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Matrix containing non-negative expression data, usually counts. Rows should be genes and columns should be cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>Pointer to an array containing the reference expression profile to normalize against. This should be of length equal to the number of rows in <code>mat</code> and should contain non-negative values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1MedianSizeFactors_1_1Results.html" title="Result of the size factor calculation.">Results</a></code> containing the size factors for each cell in <code>mat</code>. </dd></dl>

</div>
</div>
<a id="a14cc850dee0fe3462e3986434832fd48" name="a14cc850dee0fe3462e3986434832fd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14cc850dee0fe3462e3986434832fd48">&#9670;&#160;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , typename Ref , typename Out &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::MedianSizeFactors::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ref *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute per-cell size factors against a user-supplied reference profile.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric data type of the input matrix. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer index type of the input matrix. </td></tr>
    <tr><td class="paramname">Ref</td><td>Numeric data type of the reference profile. </td></tr>
    <tr><td class="paramname">Out</td><td>Numeric data type of the output vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Matrix containing non-negative expression data, usually counts. Rows should be genes and columns should be cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>Pointer to an array containing the reference expression profile to normalize against. This should be of length equal to the number of rows in <code>mat</code> and should contain non-negative values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array to use to store the output size factors. This should be of length equal to the number of columns in <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>output</code> is filled with the size factors for each cell in <code>mat</code>. </dd></dl>

</div>
</div>
<a id="a1ae3787cccfaf98bba4d473856582893" name="a1ae3787cccfaf98bba4d473856582893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae3787cccfaf98bba4d473856582893">&#9670;&#160;</a></span>run_with_mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Out  = double, typename T , typename IDX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1MedianSizeFactors_1_1Results.html">Results</a>&lt; Out &gt; scran::MedianSizeFactors::run_with_mean </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute per-cell size factors against an average pseudo-sample constructed from the row means of the input matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Out</td><td>Numeric type for the size factors. </td></tr>
    <tr><td class="paramname">T</td><td>Numeric data type of the input matrix. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer index type of the input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix containing non-negative expression data, usually counts. Rows should be genes and columns should be cells.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1MedianSizeFactors_1_1Results.html" title="Result of the size factor calculation.">Results</a></code> containing the size factors for each cell in <code>mat</code>. </dd></dl>

</div>
</div>
<a id="a1fad66012a50b1ad4eec6bc954c3c14b" name="a1fad66012a50b1ad4eec6bc954c3c14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fad66012a50b1ad4eec6bc954c3c14b">&#9670;&#160;</a></span>run_with_mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , typename Out &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::MedianSizeFactors::run_with_mean </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Out *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Compute per-cell size factors against an average pseudo-sample constructed from the row means of the input matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Numeric data type of the input matrix. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer index type of the input matrix. </td></tr>
    <tr><td class="paramname">Out</td><td>Numeric data type of the output vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Matrix containing non-negative expression data, usually counts. Rows should be genes and columns should be cells. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array to use to store the output size factors. This should be of length equal to the number of columns in <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>output</code> is filled with the size factors for each cell in <code>mat</code>. </dd></dl>

</div>
</div>
<a id="aa819da1b38830a8849bdf4cdd89b1994" name="aa819da1b38830a8849bdf4cdd89b1994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa819da1b38830a8849bdf4cdd89b1994">&#9670;&#160;</a></span>set_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a> &amp; scran::MedianSizeFactors::set_center </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1MedianSizeFactors_1_1Defaults.html#af747d883c33f4793ce28b9aade2d2ad6">Defaults::center</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to center the size factors to have a mean of unity. This is usually desirable for interpretation of relative values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MedianSizeFactors.html" title="Compute median-based size factors to handle composition bias.">MedianSizeFactors</a></code> object.</dd></dl>
<p>For more control over centering, this can be set to <code>false</code> and the resulting size factors can be passed to <code><a class="el" href="classscran_1_1CenterSizeFactors.html" title="Center size factors prior to scaling normalization.">CenterSizeFactors</a></code>. </p>

</div>
</div>
<a id="a8440bf543257fe771a5db35b0e4a9bbf" name="a8440bf543257fe771a5db35b0e4a9bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8440bf543257fe771a5db35b0e4a9bbf">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a> &amp; scran::MedianSizeFactors::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1MedianSizeFactors_1_1Defaults.html#a175bd521275c0babb11e548885761700">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MedianSizeFactors.html" title="Compute median-based size factors to handle composition bias.">MedianSizeFactors</a></code> object. </dd></dl>

</div>
</div>
<a id="a5507419988ca1925e8f60bdc99436e51" name="a5507419988ca1925e8f60bdc99436e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5507419988ca1925e8f60bdc99436e51">&#9670;&#160;</a></span>set_prior_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MedianSizeFactors.html">MedianSizeFactors</a> &amp; scran::MedianSizeFactors::set_prior_count </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em> = <code><a class="el" href="structscran_1_1MedianSizeFactors_1_1Defaults.html#a909251588d34d41237a64df1dd85552c">Defaults::prior_count</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Prior count to use for shrinking median-based size factors towards their library size-based counterparts. Larger values result in more shrinkage, while a value of zero will disable shrinkage altogether.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MedianSizeFactors.html" title="Compute median-based size factors to handle composition bias.">MedianSizeFactors</a></code> object.</dd></dl>
<p>When using shrinkage, we add a scaled version of the reference profile to each cell before computing the ratios. The scaling of the reference profile varies for each cell and is proportional to the (relative) total count of that cell. This implicitly pushes the median-based size factor towards a value that is proportional to the library size of the cell, given that the median of the ratio of the reference against a scaled version of itself is just the scaling factor, i.e., the library size.</p>
<p >The amount of shrinkage depends on the magnitude of the reference scaling. The prior count should be interpreted as the number of extra reads from the reference profile that is added to each cell. For example, the default of 10 means that the equivalent of 10 reads are added to each cell, distributed according to the reference profile. Increasing the prior count will increase the strength of the shrinkage as the reference profile has a greater contribution to the ratios. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/normalization/<a class="el" href="MedianSizeFactors_8hpp_source.html">MedianSizeFactors.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
