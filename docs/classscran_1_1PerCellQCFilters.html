<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::PerCellQCFilters Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1PerCellQCFilters.html">PerCellQCFilters</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1PerCellQCFilters-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::PerCellQCFilters Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Create filters to identify low-quality cells.  
 <a href="classscran_1_1PerCellQCFilters.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PerCellQCFilters_8hpp_source.html">PerCellQCFilters.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html" title="Results of the QC filtering.">Results</a> of the QC filtering.  <a href="structscran_1_1PerCellQCFilters_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html">Thresholds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html" title="Thresholds to define outliers on each metric.">Thresholds</a> to define outliers on each metric.  <a href="structscran_1_1PerCellQCFilters_1_1Thresholds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5aefa5d9c27f5f84081a6a89ab2a7f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PerCellQCFilters.html">PerCellQCFilters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQCFilters.html#a5aefa5d9c27f5f84081a6a89ab2a7f40">set_nmads</a> (double n=IsOutlier::Defaults::nmads)</td></tr>
<tr class="separator:a5aefa5d9c27f5f84081a6a89ab2a7f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c8cd43b53e8e2469d3ed4116ac4eec"><td class="memTemplParams" colspan="2">template&lt;typename S , typename D , typename PPTR , typename X &gt; </td></tr>
<tr class="memitem:a01c8cd43b53e8e2469d3ed4116ac4eec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html">Thresholds</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQCFilters.html#a01c8cd43b53e8e2469d3ed4116ac4eec">run</a> (size_t ncells, const S *sums, const D *detected, std::vector&lt; PPTR &gt; subset_proportions, X *filter_by_sums, X *filter_by_detected, std::vector&lt; X * &gt; filter_by_subset_proportions, X *overall_filter)</td></tr>
<tr class="separator:a01c8cd43b53e8e2469d3ed4116ac4eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f168b6493245a64d710d7ef92ed83c"><td class="memTemplParams" colspan="2">template&lt;typename B , typename S , typename D , typename PPTR , typename X &gt; </td></tr>
<tr class="memitem:a66f168b6493245a64d710d7ef92ed83c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html">Thresholds</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQCFilters.html#a66f168b6493245a64d710d7ef92ed83c">run_blocked</a> (size_t ncells, const B *block, const S *sums, const D *detected, std::vector&lt; PPTR &gt; subset_proportions, X *filter_by_sums, X *filter_by_detected, std::vector&lt; X * &gt; filter_by_subset_proportions, X *overall_filter)</td></tr>
<tr class="separator:a66f168b6493245a64d710d7ef92ed83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e054031ea7a780433450de2dcbb2dec"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, typename S , typename D , typename PPTR &gt; </td></tr>
<tr class="memitem:a1e054031ea7a780433450de2dcbb2dec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQCFilters.html#a1e054031ea7a780433450de2dcbb2dec">run</a> (size_t ncells, const S *sums, const D *detected, std::vector&lt; PPTR &gt; subset_proportions)</td></tr>
<tr class="separator:a1e054031ea7a780433450de2dcbb2dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09874cae63a2c7dbe0234bd1903954c2"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, typename B , typename S , typename D , typename PPTR &gt; </td></tr>
<tr class="memitem:a09874cae63a2c7dbe0234bd1903954c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQCFilters.html#a09874cae63a2c7dbe0234bd1903954c2">run_blocked</a> (size_t ncells, const B *block, const S *sums, const D *detected, std::vector&lt; PPTR &gt; subset_proportions)</td></tr>
<tr class="separator:a09874cae63a2c7dbe0234bd1903954c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63416b8908cd1d40fc81c176947c7ac1"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, class R &gt; </td></tr>
<tr class="memitem:a63416b8908cd1d40fc81c176947c7ac1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQCFilters.html#a63416b8908cd1d40fc81c176947c7ac1">run</a> (const R &amp;metrics)</td></tr>
<tr class="separator:a63416b8908cd1d40fc81c176947c7ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56f060cf7592e87805f9e21330cb42a"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, class R , typename B &gt; </td></tr>
<tr class="memitem:ae56f060cf7592e87805f9e21330cb42a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellQCFilters.html#ae56f060cf7592e87805f9e21330cb42a">run_blocked</a> (const R &amp;metrics, const B *block)</td></tr>
<tr class="separator:ae56f060cf7592e87805f9e21330cb42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Create filters to identify low-quality cells. </p>
<p >Use an outlier-based approach on common QC metrics (see the <code><a class="el" href="classscran_1_1PerCellQCMetrics.html" title="Compute typical per-cell quality control metrics.">PerCellQCMetrics</a></code> class) to identify low-quality cells. Specifically, low-quality cells are defined as those with:</p>
<ul>
<li>Low total counts, indicating that library preparation or sequencing depth was suboptimal.</li>
<li>Low numbers of detected features, a slightly different flavor of the above reasoning.</li>
<li>High proportions of counts in the mitochondrial (or spike-in) subsets, representing cell damage.</li>
</ul>
<p >Outliers are defined on each metric by counting the number of MADs from the median value across all cells. This assumes that most cells in the experiment are of high (or at least acceptable) quality; any anomalies are indicative of low-quality cells that should be filtered out. See the <code><a class="el" href="classscran_1_1IsOutlier.html" title="Define outlier values based on MADs.">IsOutlier</a></code> class for implementation details.</p>
<p >For the total counts and number of detected features, the outliers are defined after log-transformation of the metrics. This improves resolution at low values and ensures that the defined threshold is not negative. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a63416b8908cd1d40fc81c176947c7ac1" name="a63416b8908cd1d40fc81c176947c7ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63416b8908cd1d40fc81c176947c7ac1">&#9670;&nbsp;</a></span>run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellQCFilters::run </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>metrics</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from QC metrics, see <code><a class="el" href="classscran_1_1PerCellQCFilters.html#a01c8cd43b53e8e2469d3ed4116ac4eec">run()</a></code> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">R</td><td>Class that holds the QC metrics, typically a <code><a class="el" href="structscran_1_1PerCellQCMetrics_1_1Results.html" title="Result store for QC metric calculations.">PerCellQCMetrics::Results</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metrics</td><td>Precomputed QC metrics, typically generated by <code><a class="el" href="classscran_1_1PerCellQCMetrics.html#aedc028b2d8df9b5b28623599e060796e">PerCellQCMetrics::run</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="a1e054031ea7a780433450de2dcbb2dec" name="a1e054031ea7a780433450de2dcbb2dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e054031ea7a780433450de2dcbb2dec">&#9670;&nbsp;</a></span>run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, typename S , typename D , typename PPTR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellQCFilters::run </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_proportions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from QC metrics, see <code><a class="el" href="classscran_1_1PerCellQCFilters.html#a01c8cd43b53e8e2469d3ed4116ac4eec">run()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">S</td><td>Type of the sum. </td></tr>
    <tr><td class="paramname">D</td><td>Type of the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Type of the pointer to the subset proportions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sums</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the per-cell sums. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_proportions</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the proportion of counts in that subset for each cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="a01c8cd43b53e8e2469d3ed4116ac4eec" name="a01c8cd43b53e8e2469d3ed4116ac4eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c8cd43b53e8e2469d3ed4116ac4eec">&#9670;&nbsp;</a></span>run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename D , typename PPTR , typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html">Thresholds</a> scran::PerCellQCFilters::run </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_proportions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>filter_by_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>filter_by_detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; X * &gt;&#160;</td>
          <td class="paramname"><em>filter_by_subset_proportions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>overall_filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells as those that have outlier values for QC metrics. This uses QC metrics that are typically computed by the <code><a class="el" href="classscran_1_1PerCellQCMetrics.html" title="Compute typical per-cell quality control metrics.">PerCellQCMetrics</a></code> class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>Floating point type, used for the sum. </td></tr>
    <tr><td class="paramname">D</td><td>Integer type, used for the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Pointer to a floating point type, for the subset proportions. </td></tr>
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sums</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the per-cell sums. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_proportions</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the proportion of counts in that subset for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_sums</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to low count sums. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_detected</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a low number of detected features. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_subset_proportions</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a high proportion of counts for that subset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">overall_filter</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out for any reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html" title="Thresholds to define outliers on each metric.">Thresholds</a></code> object defining the thresholds for each QC metric. </dd></dl>

</div>
</div>
<a id="ae56f060cf7592e87805f9e21330cb42a" name="ae56f060cf7592e87805f9e21330cb42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56f060cf7592e87805f9e21330cb42a">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, class R , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellQCFilters::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from QC metrics with blocking, see <code><a class="el" href="classscran_1_1PerCellQCFilters.html#a66f168b6493245a64d710d7ef92ed83c">run_blocked()</a></code> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">R</td><td>Class that holds the QC metrics, typically a <code><a class="el" href="structscran_1_1PerCellQCMetrics_1_1Results.html" title="Result store for QC metric calculations.">PerCellQCMetrics::Results</a></code>. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type, to hold the block IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">metrics</td><td>Precomputed QC metrics, typically generated by <code><a class="el" href="classscran_1_1PerCellQCMetrics.html#aedc028b2d8df9b5b28623599e060796e">PerCellQCMetrics::run</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Optional pointer to an array of block identifiers, see <code><a class="el" href="classscran_1_1PerCellQCFilters.html#a66f168b6493245a64d710d7ef92ed83c">run_blocked()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="a09874cae63a2c7dbe0234bd1903954c2" name="a09874cae63a2c7dbe0234bd1903954c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09874cae63a2c7dbe0234bd1903954c2">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, typename B , typename S , typename D , typename PPTR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellQCFilters::run_blocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_proportions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from QC metrics with blocking, see <code><a class="el" href="classscran_1_1PerCellQCFilters.html#a66f168b6493245a64d710d7ef92ed83c">run_blocked()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">B</td><td>Pointer to an integer type, to hold the block IDs. </td></tr>
    <tr><td class="paramname">S</td><td>Type of the sum. </td></tr>
    <tr><td class="paramname">D</td><td>Type of the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Type of the pointer to the subset proportions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Optional pointer to an array of block identifiers, see <code><a class="el" href="classscran_1_1PerCellQCFilters.html#a66f168b6493245a64d710d7ef92ed83c">run_blocked()</a></code> for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sums</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the per-cell sums. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_proportions</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the proportion of counts in that subset for each cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellQCFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="a66f168b6493245a64d710d7ef92ed83c" name="a66f168b6493245a64d710d7ef92ed83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f168b6493245a64d710d7ef92ed83c">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename S , typename D , typename PPTR , typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html">Thresholds</a> scran::PerCellQCFilters::run_blocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_proportions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>filter_by_sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>filter_by_detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; X * &gt;&#160;</td>
          <td class="paramname"><em>filter_by_subset_proportions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>overall_filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from QC metrics, with blocking during outlier identification. Specifically, outliers are only computed within each block, which is useful when cells in different blocks have different distributions for the QC metrics, e.g., because they were sequenced at different depth. By blocking, we avoid confounding the outlier detection with systematic differences between blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>Pointer to an integer type, to hold the block IDs. </td></tr>
    <tr><td class="paramname">S</td><td>Floating point type, used for the sum. </td></tr>
    <tr><td class="paramname">D</td><td>Integer type, used for the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Pointer to a floating point type, for the subset proportions. </td></tr>
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of block identifiers. If provided, the array should be of length equal to <code>ncells</code>. Values should be integer IDs in <img class="formulaInl" alt="$[0, N)$" src="form_0.png"/> where <img class="formulaInl" alt="$N$" src="form_1.png"/> is the number of blocks. This can also be <code>NULL</code>, in which case all cells are assumed to belong to the same block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sums</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the per-cell sums. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_proportions</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the proportion of counts in that subset for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_sums</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to low count sums. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_detected</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a low number of detected features. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_subset_proportions</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a high proportion of counts for that subset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">overall_filter</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out for any reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellQCFilters_1_1Thresholds.html" title="Thresholds to define outliers on each metric.">Thresholds</a></code> object defining the thresholds for each QC metric in each block. </dd></dl>

</div>
</div>
<a id="a5aefa5d9c27f5f84081a6a89ab2a7f40" name="a5aefa5d9c27f5f84081a6a89ab2a7f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aefa5d9c27f5f84081a6a89ab2a7f40">&#9670;&nbsp;</a></span>set_nmads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PerCellQCFilters.html">PerCellQCFilters</a> &amp; scran::PerCellQCFilters::set_nmads </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em> = <code>IsOutlier::Defaults::nmads</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of MADs to use to define outliers, see <code><a class="el" href="classscran_1_1IsOutlier.html" title="Define outlier values based on MADs.">IsOutlier</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PerCellQCFilters.html" title="Create filters to identify low-quality cells.">PerCellQCFilters</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/quality_control/<a class="el" href="PerCellQCFilters_8hpp_source.html">PerCellQCFilters.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
