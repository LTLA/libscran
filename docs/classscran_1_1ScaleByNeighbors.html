<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::ScaleByNeighbors Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1ScaleByNeighbors-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::ScaleByNeighbors Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Scale multi-modal embeddings to adjust for differences in variance.  
 <a href="classscran_1_1ScaleByNeighbors.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScaleByNeighbors_8hpp_source.html">ScaleByNeighbors.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf21fb0b11f6a6f3f0c250c3b6fb4cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#acf21fb0b11f6a6f3f0c250c3b6fb4cb5">set_neighbors</a> (int n=<a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#ac329e6e26484712b7d8fbbb46d47ae8d">Defaults::neighbors</a>)</td></tr>
<tr class="separator:acf21fb0b11f6a6f3f0c250c3b6fb4cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3847a86a6011def45566c13c633ee04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#aa3847a86a6011def45566c13c633ee04">set_approximate</a> (int a=<a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#a8659f7467c8c29d61c1317957e1b20b6">Defaults::approximate</a>)</td></tr>
<tr class="separator:aa3847a86a6011def45566c13c633ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fd690cbc88b65016cef7fe4616a085"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#a61fd690cbc88b65016cef7fe4616a085">compute_distance</a> (int ndim, size_t ncells, const double *data) const</td></tr>
<tr class="separator:a61fd690cbc88b65016cef7fe4616a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787ad5a20e61bd9ac930242840f72448"><td class="memTemplParams" colspan="2">template&lt;class Search &gt; </td></tr>
<tr class="memitem:a787ad5a20e61bd9ac930242840f72448"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#a787ad5a20e61bd9ac930242840f72448">compute_distance</a> (const Search *search) const</td></tr>
<tr class="separator:a787ad5a20e61bd9ac930242840f72448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1452d108cbd76ed4fd31e96a86bc7d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#acf1452d108cbd76ed4fd31e96a86bc7d">compute_scale</a> (const std::pair&lt; double, double &gt; &amp;ref, const std::pair&lt; double, double &gt; &amp;target) const</td></tr>
<tr class="separator:acf1452d108cbd76ed4fd31e96a86bc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Scale multi-modal embeddings to adjust for differences in variance. </p>
<p >The premise is that we have multiple embeddings for the same set of cells, usually generated from different data modalities (e.g., RNA, protein, and so on). We would like to combine these embeddings into a single embedding for downstream analyses such as clustering and t-SNE/UMAP. The easiest combining strategy is to just concatenate the matrices together into a single embedding that contains information from all modalities. However, this is complicated by the differences in the variance between modalities, whereby higher noise in one modality might drown out biological signal in another embedding.</p>
<p >This class implements a scaling approach to equalize noise across embeddings prior to concatenation. We compute the median distance to the $k$-th nearest neighbor in each embedding; this is used as a proxy for the noise within a subpopulation containing at least $k$ cells. We then compute a scaling factor as the ratio of the medians for a "target" embedding compared to a "reference" embedding. The idea is to scale the target embedding by this factor before concatenation of matrices.</p>
<p >This approach aims to remove differences in the magnitude of noise while preserving genuine differences in biological signal. Embedding-specific subpopulations are preserved in the concatenation, provided that the difference between subpopulations is greater than that within subpopulations. By contrast, a naive scaling based on the total variance would penalize embeddings with strong biological heterogeneity. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a787ad5a20e61bd9ac930242840f72448" name="a787ad5a20e61bd9ac930242840f72448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787ad5a20e61bd9ac930242840f72448">&#9670;&nbsp;</a></span>compute_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Search &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; scran::ScaleByNeighbors::compute_distance </td>
          <td>(</td>
          <td class="paramtype">const Search *&#160;</td>
          <td class="paramname"><em>search</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Search</td><td>Search index class, typically a <code>knncolle::Base</code> subclass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search</td><td>Search index for the embedding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing the median distance to the $k$-th nearest neighbor (first) and the root-mean-squared distance across all cells (second). These values can be used in <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#acf1452d108cbd76ed4fd31e96a86bc7d">compute_scale()</a></code>. </dd></dl>

</div>
</div>
<a id="a61fd690cbc88b65016cef7fe4616a085" name="a61fd690cbc88b65016cef7fe4616a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fd690cbc88b65016cef7fe4616a085">&#9670;&nbsp;</a></span>compute_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; scran::ScaleByNeighbors::compute_distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions in the embedding. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells in the embedding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to an array containing the embedding matrix. This should be stored in column-major layout where each row is a dimension and each column is a cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing the median distance to the $k$-th nearest neighbor (first) and the root-mean-squared distance across all cells (second). These values can be used in <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#acf1452d108cbd76ed4fd31e96a86bc7d">compute_scale()</a></code>. </dd></dl>

</div>
</div>
<a id="acf1452d108cbd76ed4fd31e96a86bc7d" name="acf1452d108cbd76ed4fd31e96a86bc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1452d108cbd76ed4fd31e96a86bc7d">&#9670;&nbsp;</a></span>compute_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double scran::ScaleByNeighbors::compute_scale </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>Output of <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#acf1452d108cbd76ed4fd31e96a86bc7d">compute_scale()</a></code> for the reference embedding. The first value contains the median distance while the second value contains the RMSD. </td></tr>
    <tr><td class="paramname">target</td><td>Output of <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#acf1452d108cbd76ed4fd31e96a86bc7d">compute_scale()</a></code> for the target embedding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaling factor to apply to the target embedding. Scaling all values in the target matrix by the factor will equalize the magnitude of the noise to that of the reference embedding.</dd></dl>
<p>If either of the median distances is zero, this function automatically switches to the root-mean-square-distance to the $k$-th neighbor. The scaling factor is then defined as the ratio of the RMSDs between embeddings. If the reference RMSDs is zero, this function will return zero; if the target RMSD is zero, this function will return positive infinity. </p>

</div>
</div>
<a id="aa3847a86a6011def45566c13c633ee04" name="aa3847a86a6011def45566c13c633ee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3847a86a6011def45566c13c633ee04">&#9670;&nbsp;</a></span>set_approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp; scran::ScaleByNeighbors::set_approximate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#a8659f7467c8c29d61c1317957e1b20b6">Defaults::approximate</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Whether to perform an approximate neighbor search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScaleByNeighbors.html" title="Scale multi-modal embeddings to adjust for differences in variance.">ScaleByNeighbors</a></code> instance.</dd></dl>
<p>This parameter only has an effect when an array is passed to <code>run()</code>, otherwise the search uses the algorithm specified by the <b>knncolle</b> class. </p>

</div>
</div>
<a id="acf21fb0b11f6a6f3f0c250c3b6fb4cb5" name="acf21fb0b11f6a6f3f0c250c3b6fb4cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf21fb0b11f6a6f3f0c250c3b6fb4cb5">&#9670;&nbsp;</a></span>set_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp; scran::ScaleByNeighbors::set_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#ac329e6e26484712b7d8fbbb46d47ae8d">Defaults::neighbors</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of neighbors used in the nearest neighbor search. This can be interpreted as the minimum size of each subpopulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScaleByNeighbors.html" title="Scale multi-modal embeddings to adjust for differences in variance.">ScaleByNeighbors</a></code> instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/dimensionality_reduction/<a class="el" href="ScaleByNeighbors_8hpp_source.html">ScaleByNeighbors.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
