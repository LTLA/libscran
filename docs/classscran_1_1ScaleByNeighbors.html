<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::ScaleByNeighbors Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classscran_1_1ScaleByNeighbors-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::ScaleByNeighbors Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Scale multi-modal embeddings to adjust for differences in variance.  
 <a href="classscran_1_1ScaleByNeighbors.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScaleByNeighbors_8hpp_source.html">ScaleByNeighbors.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf21fb0b11f6a6f3f0c250c3b6fb4cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#acf21fb0b11f6a6f3f0c250c3b6fb4cb5">set_neighbors</a> (int n=<a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#ac329e6e26484712b7d8fbbb46d47ae8d">Defaults::neighbors</a>)</td></tr>
<tr class="separator:acf21fb0b11f6a6f3f0c250c3b6fb4cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3847a86a6011def45566c13c633ee04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#aa3847a86a6011def45566c13c633ee04">set_approximate</a> (int a=<a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#a8659f7467c8c29d61c1317957e1b20b6">Defaults::approximate</a>)</td></tr>
<tr class="separator:aa3847a86a6011def45566c13c633ee04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f5e00b03d7d227b67e627b782b7193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#a35f5e00b03d7d227b67e627b782b7193">set_num_threads</a> (int n=<a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#a4aac6f0569099d41a6e51ffc9fb23064">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a35f5e00b03d7d227b67e627b782b7193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fd690cbc88b65016cef7fe4616a085"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#a61fd690cbc88b65016cef7fe4616a085">compute_distance</a> (int ndim, size_t ncells, const double *data) const</td></tr>
<tr class="separator:a61fd690cbc88b65016cef7fe4616a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787ad5a20e61bd9ac930242840f72448"><td class="memTemplParams" colspan="2">template&lt;class Search &gt; </td></tr>
<tr class="memitem:a787ad5a20e61bd9ac930242840f72448"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#a787ad5a20e61bd9ac930242840f72448">compute_distance</a> (const Search *search) const</td></tr>
<tr class="separator:a787ad5a20e61bd9ac930242840f72448"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0c63ae4793732b14ae902bc165e3c968"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#a0c63ae4793732b14ae902bc165e3c968">compute_scale</a> (const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;distances)</td></tr>
<tr class="separator:a0c63ae4793732b14ae902bc165e3c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257b5d2f53b85a7769110c205d101be8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#a257b5d2f53b85a7769110c205d101be8">compute_scale</a> (const std::pair&lt; double, double &gt; &amp;ref, const std::pair&lt; double, double &gt; &amp;target)</td></tr>
<tr class="separator:a257b5d2f53b85a7769110c205d101be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2457f764f63b1a3874257b7dca97478"><td class="memTemplParams" colspan="2">template&lt;typename Embed &gt; </td></tr>
<tr class="memitem:ab2457f764f63b1a3874257b7dca97478"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScaleByNeighbors.html#ab2457f764f63b1a3874257b7dca97478">combine_scaled_embeddings</a> (const std::vector&lt; int &gt; &amp;ndims, size_t ncells, const std::vector&lt; Embed &gt; &amp;embeddings, const std::vector&lt; double &gt; &amp;scaling, double *output)</td></tr>
<tr class="separator:ab2457f764f63b1a3874257b7dca97478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Scale multi-modal embeddings to adjust for differences in variance. </p>
<p>The premise is that we have multiple embeddings for the same set of cells, usually generated from different data modalities (e.g., RNA, protein, and so on). We would like to combine these embeddings into a single embedding for downstream analyses such as clustering and t-SNE/UMAP. The easiest combining strategy is to just concatenate the matrices together into a single embedding that contains information from all modalities. However, this is complicated by the differences in the variance between modalities, whereby higher noise in one modality might drown out biological signal in another embedding.</p>
<p>This class implements a scaling approach to equalize noise across embeddings prior to concatenation. We compute the median distance to the $k$-th nearest neighbor in each embedding; this is used as a proxy for the noise within a subpopulation containing at least $k$ cells. We then compute a scaling factor as the ratio of the medians for a "target" embedding compared to a "reference" embedding. The idea is to scale the target embedding by this factor before concatenation of matrices.</p>
<p>This approach aims to remove differences in the magnitude of noise while preserving genuine differences in biological signal. Embedding-specific subpopulations are preserved in the concatenation, provided that the difference between subpopulations is greater than that within subpopulations. By contrast, a naive scaling based on the total variance would penalize embeddings with strong biological heterogeneity. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acf21fb0b11f6a6f3f0c250c3b6fb4cb5" name="acf21fb0b11f6a6f3f0c250c3b6fb4cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf21fb0b11f6a6f3f0c250c3b6fb4cb5">&#9670;&#160;</a></span>set_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp; scran::ScaleByNeighbors::set_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#ac329e6e26484712b7d8fbbb46d47ae8d">Defaults::neighbors</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of neighbors used in the nearest neighbor search. This can be interpreted as the minimum size of each subpopulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScaleByNeighbors.html" title="Scale multi-modal embeddings to adjust for differences in variance.">ScaleByNeighbors</a></code> instance. </dd></dl>

</div>
</div>
<a id="aa3847a86a6011def45566c13c633ee04" name="aa3847a86a6011def45566c13c633ee04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3847a86a6011def45566c13c633ee04">&#9670;&#160;</a></span>set_approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp; scran::ScaleByNeighbors::set_approximate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#a8659f7467c8c29d61c1317957e1b20b6">Defaults::approximate</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Whether to perform an approximate neighbor search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScaleByNeighbors.html" title="Scale multi-modal embeddings to adjust for differences in variance.">ScaleByNeighbors</a></code> instance.</dd></dl>
<p>This parameter only has an effect when an array is passed to <code>run()</code>, otherwise the search uses the algorithm specified by the <b>knncolle</b> class. </p>

</div>
</div>
<a id="a35f5e00b03d7d227b67e627b782b7193" name="a35f5e00b03d7d227b67e627b782b7193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f5e00b03d7d227b67e627b782b7193">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScaleByNeighbors.html">ScaleByNeighbors</a> &amp; scran::ScaleByNeighbors::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1ScaleByNeighbors_1_1Defaults.html#a4aac6f0569099d41a6e51ffc9fb23064">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScaleByNeighbors.html" title="Scale multi-modal embeddings to adjust for differences in variance.">ScaleByNeighbors</a></code> object. </dd></dl>

</div>
</div>
<a id="a61fd690cbc88b65016cef7fe4616a085" name="a61fd690cbc88b65016cef7fe4616a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fd690cbc88b65016cef7fe4616a085">&#9670;&#160;</a></span>compute_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; scran::ScaleByNeighbors::compute_distance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions in the embedding. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells in the embedding. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to an array containing the embedding matrix. This should be stored in column-major layout where each row is a dimension and each column is a cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing the median distance to the $k$-th nearest neighbor (first) and the root-mean-squared distance across all cells (second). These values can be used in <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#a0c63ae4793732b14ae902bc165e3c968">compute_scale()</a></code>. </dd></dl>

</div>
</div>
<a id="a787ad5a20e61bd9ac930242840f72448" name="a787ad5a20e61bd9ac930242840f72448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787ad5a20e61bd9ac930242840f72448">&#9670;&#160;</a></span>compute_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Search &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; double, double &gt; scran::ScaleByNeighbors::compute_distance </td>
          <td>(</td>
          <td class="paramtype">const Search *&#160;</td>
          <td class="paramname"><em>search</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Search</td><td>Search index class, typically a <code>knncolle::Base</code> subclass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search</td><td>Search index for the embedding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing the median distance to the $k$-th nearest neighbor (first) and the root-mean-squared distance across all cells (second). These values can be used in <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#a0c63ae4793732b14ae902bc165e3c968">compute_scale()</a></code>. </dd></dl>

</div>
</div>
<a id="a0c63ae4793732b14ae902bc165e3c968" name="a0c63ae4793732b14ae902bc165e3c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c63ae4793732b14ae902bc165e3c968">&#9670;&#160;</a></span>compute_scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; double &gt; scran::ScaleByNeighbors::compute_scale </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>distances</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scaling factors for a group of embeddings, given the neighbor distances computed by <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#a61fd690cbc88b65016cef7fe4616a085">compute_distance()</a></code>. This aims to scale each embedding so that the within-population variances are equal across embeddings. The "reference" embedding is defined as the first embedding with a non-zero RMSD; other than this requirement, the exact choice of reference has no actual impact on the relative values of the scaling factors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distances</td><td>Vector of distances for embeddings, as computed by <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#a0c63ae4793732b14ae902bc165e3c968">compute_scale()</a></code> on each embedding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of scaling factors of length equal to that of <code>distances</code>, to be applied to each embedding. </dd></dl>

</div>
</div>
<a id="a257b5d2f53b85a7769110c205d101be8" name="a257b5d2f53b85a7769110c205d101be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257b5d2f53b85a7769110c205d101be8">&#9670;&#160;</a></span>compute_scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double scran::ScaleByNeighbors::compute_scale </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scaling factor to be applied to a target embedding relative to a reference. This aims to scale the target so that the within-population variance is equal to that of the reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>Output of <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#a61fd690cbc88b65016cef7fe4616a085">compute_distance()</a></code> for the reference embedding. The first value contains the median distance while the second value contains the RMSD. </td></tr>
    <tr><td class="paramname">target</td><td>Output of <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#a61fd690cbc88b65016cef7fe4616a085">compute_distance()</a></code> for the target embedding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scaling factor to apply to the target embedding. Scaling all values in the target matrix by the factor will equalize the magnitude of the noise to that of the reference embedding.</dd></dl>
<p>If either of the median distances is zero, this function automatically switches to the root-mean-square-distance to the $k$-th neighbor. The scaling factor is then defined as the ratio of the RMSDs between embeddings. If the reference RMSDs is zero, this function will return zero; if the target RMSD is zero, this function will return positive infinity. </p>

</div>
</div>
<a id="ab2457f764f63b1a3874257b7dca97478" name="ab2457f764f63b1a3874257b7dca97478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2457f764f63b1a3874257b7dca97478">&#9670;&#160;</a></span>combine_scaled_embeddings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Embed &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void scran::ScaleByNeighbors::combine_scaled_embeddings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Embed &gt; &amp;&#160;</td>
          <td class="paramname"><em>embeddings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Combine multiple embeddings into a single embedding matrix, possibly after scaling each embedding. This is done row-wise, i.e., the coordinates are concatenated across embeddings for each column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Embed</td><td>Pointer type to the input embeddings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndims</td><td>Vector containing the number of dimensions in each embedding. </td></tr>
    <tr><td class="paramname">ncells</td><td>Number of cells in each embedding. </td></tr>
    <tr><td class="paramname">embeddings</td><td>Vector of pointers of length equal to that of <code>ndims</code>. Each pointer refers to an array containing an embedding matrix, which should be in column-major format with dimensions in rows and cells in columns. The number of rows should be equal to the corresponding element in <code>ndims</code> and the number of columns should be equal to <code>ncells</code>. </td></tr>
    <tr><td class="paramname">scaling</td><td>Scaling to apply to each embedding, usually from <code><a class="el" href="classscran_1_1ScaleByNeighbors.html#a0c63ae4793732b14ae902bc165e3c968">compute_scale()</a></code>. This should be of length equal to that of <code>ndims</code>. </td></tr>
    <tr><td class="paramname">output</td><td>Pointer to the output array. This should be of length equal to the product of <code>ncells</code> and the sum of <code>ndims</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>output</code> is filled with the combined embeddings in column-major format. Each row corresponds to a dimension while each column corresponds to a cell. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/dimensionality_reduction/<a class="el" href="ScaleByNeighbors_8hpp_source.html">ScaleByNeighbors.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
