<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::AggregateAcrossCells Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classscran_1_1AggregateAcrossCells-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::AggregateAcrossCells Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Aggregate expression values across cells.  
 <a href="classscran_1_1AggregateAcrossCells.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AggregateAcrossCells_8hpp_source.html">AggregateAcrossCells.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html">Combinations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique combinations of factors.  <a href="structscran_1_1AggregateAcrossCells_1_1Combinations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters for aggregation.  <a href="structscran_1_1AggregateAcrossCells_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the aggregation results.  <a href="structscran_1_1AggregateAcrossCells_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdc190e40b34a4b8d401b1805a59ab29"><td class="memTemplParams" colspan="2">template&lt;typename Data , typename Index , typename Factor , typename Sum , typename Detected &gt; </td></tr>
<tr class="memitem:abdc190e40b34a4b8d401b1805a59ab29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html#abdc190e40b34a4b8d401b1805a59ab29">run</a> (const tatami::Matrix&lt; Data, Index &gt; *input, const Factor *factor, std::vector&lt; Sum * &gt; sums, std::vector&lt; Detected * &gt; detected)</td></tr>
<tr class="separator:abdc190e40b34a4b8d401b1805a59ab29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d609cbe6bb3be5808fff3909c07a89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html#a7d609cbe6bb3be5808fff3909c07a89b">set_compute_sums</a> (bool c=<a class="el" href="structscran_1_1AggregateAcrossCells_1_1Defaults.html#a4299b3f74f68fc088d4b2bacf77c5fee">Defaults::compute_sums</a>)</td></tr>
<tr class="separator:a7d609cbe6bb3be5808fff3909c07a89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bd0c4736135d095ab39077bae8e9c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html#a94bd0c4736135d095ab39077bae8e9c8">set_compute_detected</a> (bool c=<a class="el" href="structscran_1_1AggregateAcrossCells_1_1Defaults.html#a75c5c2a8222c372e3d6f419b3e1f8ffe">Defaults::compute_detected</a>)</td></tr>
<tr class="separator:a94bd0c4736135d095ab39077bae8e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e007b21006c06e0a9c2317cc53b870f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html#a9e007b21006c06e0a9c2317cc53b870f">set_num_threads</a> (int n=<a class="el" href="structscran_1_1AggregateAcrossCells_1_1Defaults.html#a160440174e9ab2842b219b6bfa6d4572">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a9e007b21006c06e0a9c2317cc53b870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892fb19e8090f8d92025deb34fc36736"><td class="memTemplParams" colspan="2">template&lt;typename Sum  = double, typename Detected  = int, typename Data , typename Index , typename Factor &gt; </td></tr>
<tr class="memitem:a892fb19e8090f8d92025deb34fc36736"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Results.html">Results</a>&lt; Sum, Detected &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html#a892fb19e8090f8d92025deb34fc36736">run</a> (const tatami::Matrix&lt; Data, Index &gt; *input, const Factor *factor)</td></tr>
<tr class="separator:a892fb19e8090f8d92025deb34fc36736"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a78bfad996edef3a958377c50dabdeff4"><td class="memTemplParams" colspan="2">template&lt;typename Factor , typename Combined &gt; </td></tr>
<tr class="memitem:a78bfad996edef3a958377c50dabdeff4"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html">Combinations</a>&lt; Factor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html#a78bfad996edef3a958377c50dabdeff4">combine_factors</a> (size_t n, std::vector&lt; const Factor * &gt; factors, Combined *combined)</td></tr>
<tr class="separator:a78bfad996edef3a958377c50dabdeff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36a7bc1ed0d40aa179c3a486a15c0ea"><td class="memTemplParams" colspan="2">template&lt;typename Combined  = int, typename Factor &gt; </td></tr>
<tr class="memitem:ae36a7bc1ed0d40aa179c3a486a15c0ea"><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html">Combinations</a>&lt; Factor &gt;, std::vector&lt; Combined &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AggregateAcrossCells.html#ae36a7bc1ed0d40aa179c3a486a15c0ea">combine_factors</a> (size_t n, std::vector&lt; const Factor * &gt; factors)</td></tr>
<tr class="separator:ae36a7bc1ed0d40aa179c3a486a15c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Aggregate expression values across cells. </p>
<p>This class computes the sum of expression values for each grouping of cells, typically for the creation of pseudo-bulk expression profiles for cluster/sample combinations. Expression values are generally expected to be counts, though the same code can be trivially re-used to compute the average log-expression. We can also report the number of cells with detected (i.e., positive) expression values in each grouping. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a78bfad996edef3a958377c50dabdeff4" name="a78bfad996edef3a958377c50dabdeff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bfad996edef3a958377c50dabdeff4">&#9670;&#160;</a></span>combine_factors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Factor , typename Combined &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html">Combinations</a>&lt; Factor &gt; scran::AggregateAcrossCells::combine_factors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const Factor * &gt;&#160;</td>
          <td class="paramname"><em>factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combined *&#160;</td>
          <td class="paramname"><em>combined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor</td><td>Factor type. </td></tr>
    <tr><td class="paramname">Combined</td><td>Type of the combined factor. May need to be different from <code>Factor</code> if the latter does not have enough unique levels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>Pointers to arrays of length <code>n</code>, each containing a different factor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">combined</td><td>Pointer to an array of length <code>n</code>, in which the combined factor is to be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html" title="Unique combinations of factors.">Combinations</a></code> object is returned containing the unique combinations of levels observed in <code>factors</code>. A combined factor is saved to <code>combined</code>; values are indices of combinations in the output <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html" title="Unique combinations of factors.">Combinations</a></code> object.</dd></dl>
<p>This function compresses multiple <code>factors</code> into a single <code>combined</code> factor, which can then be used as the <code>factor</code> in <code><a class="el" href="classscran_1_1AggregateAcrossCells.html#abdc190e40b34a4b8d401b1805a59ab29">run()</a></code>. In this manner, <code><a class="el" href="classscran_1_1AggregateAcrossCells.html" title="Aggregate expression values across cells.">AggregateAcrossCells</a></code> can easily handle aggregation across any number of factors. </p>

</div>
</div>
<a id="ae36a7bc1ed0d40aa179c3a486a15c0ea" name="ae36a7bc1ed0d40aa179c3a486a15c0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36a7bc1ed0d40aa179c3a486a15c0ea">&#9670;&#160;</a></span>combine_factors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Combined  = int, typename Factor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt; <a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html">Combinations</a>&lt; Factor &gt;, std::vector&lt; Combined &gt; &gt; scran::AggregateAcrossCells::combine_factors </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const Factor * &gt;&#160;</td>
          <td class="paramname"><em>factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Factor</td><td>Factor type. </td></tr>
    <tr><td class="paramname">Combined</td><td>Type of the combined factor. May need to be different from <code>Factor</code> if the latter does not have enough unique levels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations (i.e., cells). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factors</td><td>Pointers to arrays of length <code>n</code>, each containing a different factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing:</dd></dl>
<ul>
<li>A <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Combinations.html" title="Unique combinations of factors.">Combinations</a></code> object, containing the unique combinations of levels observed in <code>factors</code>.</li>
<li>A vector of length <code>n</code> containing the combined factor.</li>
</ul>
<p>See the other <code><a class="el" href="classscran_1_1AggregateAcrossCells.html#a78bfad996edef3a958377c50dabdeff4">combine_factors()</a></code> method for details. </p>

</div>
</div>
<a id="abdc190e40b34a4b8d401b1805a59ab29" name="abdc190e40b34a4b8d401b1805a59ab29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc190e40b34a4b8d401b1805a59ab29">&#9670;&#160;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data , typename Index , typename Factor , typename Sum , typename Detected &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::AggregateAcrossCells::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Data, Index &gt; *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor *&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Sum * &gt;&#160;</td>
          <td class="paramname"><em>sums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Detected * &gt;&#160;</td>
          <td class="paramname"><em>detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Data</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor</td><td>Integer type of the factor. </td></tr>
    <tr><td class="paramname">Sum</td><td>Type of the sum, usually the same as <code>Data</code>. </td></tr>
    <tr><td class="paramname">Detected</td><td>Type for the number of detected cells, usually integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level for each cell. All levels should be integers in $[0, N)$ where $N$ is the number of unique levels. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sums</td><td>Vector of length $N$ (see <code>factor</code>), containing pointers to arrays of length equal to the number of columns of <code>input</code>. These will be filled with the summed expression across all cells in the corresponding level for each gene. Alternatively, if the vector is of length 0, no sums will be computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Vector of length $N$ (see <code>factor</code>), containing pointers to arrays of length equal to the number of columns of <code>input</code>. These will be filled with the number of cells with detected expression in the corresponding level for each gene. Alternatively, if the vector is of length 0, no numbers will be computed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>sums</code> and <code>detected</code> are filled on output. If either are empty, the corresponding statistic will not be computed. </dd></dl>

</div>
</div>
<a id="a7d609cbe6bb3be5808fff3909c07a89b" name="a7d609cbe6bb3be5808fff3909c07a89b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d609cbe6bb3be5808fff3909c07a89b">&#9670;&#160;</a></span>set_compute_sums()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a> &amp; scran::AggregateAcrossCells::set_compute_sums </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Defaults.html#a4299b3f74f68fc088d4b2bacf77c5fee">Defaults::compute_sums</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to compute the sum within each factor level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AggregateAcrossCells.html" title="Aggregate expression values across cells.">AggregateAcrossCells</a></code> object.</dd></dl>
<p>This function only affects <code><a class="el" href="classscran_1_1AggregateAcrossCells.html#abdc190e40b34a4b8d401b1805a59ab29">run()</a></code> when <code>sums</code> and <code>detected</code> are not supplied as inputs. </p>

</div>
</div>
<a id="a94bd0c4736135d095ab39077bae8e9c8" name="a94bd0c4736135d095ab39077bae8e9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bd0c4736135d095ab39077bae8e9c8">&#9670;&#160;</a></span>set_compute_detected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a> &amp; scran::AggregateAcrossCells::set_compute_detected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Defaults.html#a75c5c2a8222c372e3d6f419b3e1f8ffe">Defaults::compute_detected</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to compute the number of detected cells within each factor level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AggregateAcrossCells.html" title="Aggregate expression values across cells.">AggregateAcrossCells</a></code> object.</dd></dl>
<p>This function only affects <code><a class="el" href="classscran_1_1AggregateAcrossCells.html#abdc190e40b34a4b8d401b1805a59ab29">run()</a></code> when <code>sums</code> and <code>detected</code> are not supplied as inputs. </p>

</div>
</div>
<a id="a9e007b21006c06e0a9c2317cc53b870f" name="a9e007b21006c06e0a9c2317cc53b870f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e007b21006c06e0a9c2317cc53b870f">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AggregateAcrossCells.html">AggregateAcrossCells</a> &amp; scran::AggregateAcrossCells::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Defaults.html#a160440174e9ab2842b219b6bfa6d4572">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AggregateAcrossCells.html" title="Aggregate expression values across cells.">AggregateAcrossCells</a></code> object. </dd></dl>

</div>
</div>
<a id="a892fb19e8090f8d92025deb34fc36736" name="a892fb19e8090f8d92025deb34fc36736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892fb19e8090f8d92025deb34fc36736">&#9670;&#160;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sum  = double, typename Detected  = int, typename Data , typename Index , typename Factor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Results.html">Results</a>&lt; Sum, Detected &gt; scran::AggregateAcrossCells::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; Data, Index &gt; *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Factor *&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Sum</td><td>Type of the sum, should be numeric. </td></tr>
    <tr><td class="paramname">Detected</td><td>Type for the number of detected cells, usually integer. </td></tr>
    <tr><td class="paramname">Data</td><td>Type of data in the input matrix, should be numeric. </td></tr>
    <tr><td class="paramname">Index</td><td>Integer type of index in the input matrix. </td></tr>
    <tr><td class="paramname">Factor</td><td>Integer type of the factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>The input matrix where rows are features and columns are cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factor</td><td>Pointer to an array of length equal to the number of columns of <code>input</code>, containing the factor level for each cell. All levels should be integers in $[0, N)$ where $N$ is the number of unique levels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Results.html" title="Container for the aggregation results.">Results</a></code> object is returned containing the summed expression and the number of detected cells within each factor level across all genes.</dd></dl>
<p>This function will respect any user-supplied setting of <code><a class="el" href="classscran_1_1AggregateAcrossCells.html#a7d609cbe6bb3be5808fff3909c07a89b">set_compute_sums()</a></code> and <code><a class="el" href="classscran_1_1AggregateAcrossCells.html#a94bd0c4736135d095ab39077bae8e9c8">set_compute_detected()</a></code>. If either/both are false, the corresponding statistic(s) will not be computed and the corresponding vector in <code><a class="el" href="structscran_1_1AggregateAcrossCells_1_1Results.html" title="Container for the aggregation results.">Results</a></code> will be empty. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/aggregation/<a class="el" href="AggregateAcrossCells_8hpp_source.html">AggregateAcrossCells.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
