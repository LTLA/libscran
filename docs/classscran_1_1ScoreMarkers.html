<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::ScoreMarkers Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1ScoreMarkers-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::ScoreMarkers Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Score each gene as a candidate marker for each group of cells.  
 <a href="classscran_1_1ScoreMarkers.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScoreMarkers_8hpp_source.html">ScoreMarkers.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1ScoreMarkers_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a> of the marker scoring.  <a href="structscran_1_1ScoreMarkers_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a836ea0c31fa496f274943e79035314b5"><td class="memItemLeft" align="right" valign="top">typedef std::array&lt; bool, differential_analysis::n_summaries &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a></td></tr>
<tr class="separator:a836ea0c31fa496f274943e79035314b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e7f5ec97f4628bdb2a6739670614401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a9e7f5ec97f4628bdb2a6739670614401">set_threshold</a> (double t=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#ac1138a7ec0df83d0af5d43af9bf7f14b">Defaults::threshold</a>)</td></tr>
<tr class="separator:a9e7f5ec97f4628bdb2a6739670614401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc06d8f9005175502e8ff56a55dd4a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:acc06d8f9005175502e8ff56a55dd4a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd5fd4f1b273131eb9bce7b59d0eb63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#accd5fd4f1b273131eb9bce7b59d0eb63">set_compute_cohen</a> (bool c)</td></tr>
<tr class="separator:accd5fd4f1b273131eb9bce7b59d0eb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae552e125db5264ab1719cf12fdc318fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ae552e125db5264ab1719cf12fdc318fe">set_compute_cohen</a> (differential_analysis::summary s, bool c)</td></tr>
<tr class="separator:ae552e125db5264ab1719cf12fdc318fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b4328dcdd409b2c7156410a9cf1b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a79b4328dcdd409b2c7156410a9cf1b93">set_compute_auc</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:a79b4328dcdd409b2c7156410a9cf1b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33b7936392e32122febd819b8b5b7de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#aa33b7936392e32122febd819b8b5b7de">set_compute_auc</a> (bool c)</td></tr>
<tr class="separator:aa33b7936392e32122febd819b8b5b7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a05963063e92a4ac296dfa627de4503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a8a05963063e92a4ac296dfa627de4503">set_compute_auc</a> (differential_analysis::summary s, bool c)</td></tr>
<tr class="separator:a8a05963063e92a4ac296dfa627de4503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f0dfe45359d007ef9ae492d7e5571c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#aa8f0dfe45359d007ef9ae492d7e5571c">set_compute_lfc</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:aa8f0dfe45359d007ef9ae492d7e5571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5763df3dc998e92712f2fd8add1edf66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a5763df3dc998e92712f2fd8add1edf66">set_compute_lfc</a> (bool c)</td></tr>
<tr class="separator:a5763df3dc998e92712f2fd8add1edf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd093b0bedf7e9b8d6d81903778ea7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a8dd093b0bedf7e9b8d6d81903778ea7a">set_compute_lfc</a> (differential_analysis::summary s, bool c)</td></tr>
<tr class="separator:a8dd093b0bedf7e9b8d6d81903778ea7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1220483b8d4b740ead9bca8c70fa2362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a1220483b8d4b740ead9bca8c70fa2362">set_compute_delta_detected</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:a1220483b8d4b740ead9bca8c70fa2362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fba4be4aae73861a38e82727519d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a09fba4be4aae73861a38e82727519d4e">set_compute_delta_detected</a> (bool c)</td></tr>
<tr class="separator:a09fba4be4aae73861a38e82727519d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519f725507ea407f7fd2a98dfc2f98c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a519f725507ea407f7fd2a98dfc2f98c2">set_compute_delta_detected</a> (differential_analysis::summary s, bool c)</td></tr>
<tr class="separator:a519f725507ea407f7fd2a98dfc2f98c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da89baba3b8b60aa87530b81ec8fe9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a9da89baba3b8b60aa87530b81ec8fe9e">set_summary_min</a> (bool s)</td></tr>
<tr class="separator:a9da89baba3b8b60aa87530b81ec8fe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83ea5de6bc23dcb6e73a5c97b62babf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ab83ea5de6bc23dcb6e73a5c97b62babf">set_summary_mean</a> (bool s)</td></tr>
<tr class="separator:ab83ea5de6bc23dcb6e73a5c97b62babf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a45151048b3aec1ab7c076470e20b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ae3a45151048b3aec1ab7c076470e20b5">set_summary_median</a> (bool s)</td></tr>
<tr class="separator:ae3a45151048b3aec1ab7c076470e20b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3379a274da6d5edfcef09e18191e553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ab3379a274da6d5edfcef09e18191e553">set_summary_max</a> (bool s)</td></tr>
<tr class="separator:ab3379a274da6d5edfcef09e18191e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eefc84e9355d6d45d24a6a35aea2777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a4eefc84e9355d6d45d24a6a35aea2777">set_summary_min_rank</a> (bool s)</td></tr>
<tr class="separator:a4eefc84e9355d6d45d24a6a35aea2777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd8272701d34277064610f6ad9dd90b"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename Stat &gt; </td></tr>
<tr class="memitem:afbd8272701d34277064610f6ad9dd90b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run</a> (const Matrix *p, const G *group, std::vector&lt; Stat * &gt; means, std::vector&lt; Stat * &gt; detected, std::vector&lt; std::vector&lt; Stat * &gt; &gt; cohen, std::vector&lt; std::vector&lt; Stat * &gt; &gt; auc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; lfc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; delta_detected)</td></tr>
<tr class="separator:afbd8272701d34277064610f6ad9dd90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4ffd18f162583602f9caf3559235c0"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename B , typename Stat &gt; </td></tr>
<tr class="memitem:a5a4ffd18f162583602f9caf3559235c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a5a4ffd18f162583602f9caf3559235c0">run_blocked</a> (const Matrix *p, const G *group, const B *block, std::vector&lt; std::vector&lt; Stat * &gt; &gt; means, std::vector&lt; std::vector&lt; Stat * &gt; &gt; detected, std::vector&lt; std::vector&lt; Stat * &gt; &gt; cohen, std::vector&lt; std::vector&lt; Stat * &gt; &gt; auc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; lfc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; delta_detected)</td></tr>
<tr class="separator:a5a4ffd18f162583602f9caf3559235c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c1f66cb31e0fba3440164600c72ede"><td class="memTemplParams" colspan="2">template&lt;typename Stat  = double, class MAT , typename G &gt; </td></tr>
<tr class="memitem:a92c1f66cb31e0fba3440164600c72ede"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a92c1f66cb31e0fba3440164600c72ede">run</a> (const MAT *p, const G *group)</td></tr>
<tr class="separator:a92c1f66cb31e0fba3440164600c72ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8995f7687e95134e1728fb7c5183be6"><td class="memTemplParams" colspan="2">template&lt;typename Stat  = double, class MAT , typename G , typename B &gt; </td></tr>
<tr class="memitem:aa8995f7687e95134e1728fb7c5183be6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#aa8995f7687e95134e1728fb7c5183be6">run_blocked</a> (const MAT *p, const G *group, const B *block)</td></tr>
<tr class="separator:aa8995f7687e95134e1728fb7c5183be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Score each gene as a candidate marker for each group of cells. </p>
<p >Markers are identified by differential expression analyses between pairs of groups of cells (e.g., clusters, cell types). Given <code>n</code> groups, each group is involved in <code>n - 1</code> pairwise comparisons and thus has <code>n - 1</code> effect sizes. For each group, we compute summary statistics - e.g., the minimum, median, mean - of the effect sizes across all of that group's comparisons. Users can then sort by any of these summaries to obtain a ranking of potential marker genes for each group. The choice of effect size and summary statistic determines the characteristics of the resulting marker set.</p>
<h1><a class="anchor" id="effect-sizes"></a>
Effect sizes</h1>
<p >The log-fold change (LFC) is the difference in the mean log-expression between groups. This is fairly straightforward to interpret - as log-fold change of +1 corresponds to a two-fold upregulation in the first group compared to the second. For this interpretation, we assume that the input matrix contains log-transformed normalized expression values.</p>
<p >The delta-detected is the difference in the proportion of cells with detected expression between groups. This lies between 1 and -1, with the extremes occurring when a gene is silent in one group and detected in all cells of the other group. For this interpretation, we assume that the input matrix contains non-negative expression values, where a value of zero corresponds to lack of detectable expression.</p>
<p >Cohen's d is the standardized log-fold change between two groups. This is defined as the difference in the mean log-expression for each group scaled by the average standard deviation across the two groups. (Technically, we should use the pooled variance; however, this introduces some unpleasant asymmetry depending on the variance of the larger group, so we take a simple average instead.) A positive value indicates that the gene is upregulated in the first gene compared to the second. Cohen's d is analogous to the t-statistic in a two-sample t-test and avoids spuriously large effect sizes from comparisons between highly variable groups. We can also interpret Cohen's d as the number of standard deviations between the two group means.</p>
<p >The area under the curve (AUC) can be interpreted as the probability that a randomly chosen observation in one group is greater than a randomly chosen observation in the other group. Values greater than 0.5 indicate that a gene is upregulated in the first group. The AUC is closely related to the U-statistic used in the Wilcoxon rank sum test. The key difference between the AUC and Cohen's d is that the former is less sensitive to the variance within each group, e.g., if two distributions exhibit no overlap, the AUC is the same regardless of the variance of each distribution. This may or may not be desirable as it improves robustness to outliers but reduces the information available to obtain a highly resolved ranking.</p>
<h1><a class="anchor" id="lfc-threshold"></a>
With a log-fold change threshold</h1>
<p >Setting a log-fold change threshold can be helpful as it prioritizes genes with large shifts in expression instead of those with low variances. Currently, only positive thresholds are supported - this focuses on genes upregulated in the first group compared to the second. The effect size definitions are generalized when testing against a non-zero log-fold change threshold.</p>
<p >Cohen's d is redefined as the standardized difference between the observed log-fold change and the specified threshold, analogous to the TREAT method from <b>limma</b>. Large positive values are only obtained when the observed log-fold change is significantly greater than the threshold. For example, if we had a threshold of 2 and we obtained a Cohen's d of 3, this means that the observed log-fold change was 3 standard deviations above 2. Importantly, a negative Cohen's d cannot be intepreted as downregulation, as the log-fold change may still be positive but less than the threshold.</p>
<p >The AUC generalized to the probability of obtaining a random observation in one group that is greater than a random observation plus the threshold in the other group. For example, if we had a threshold of 2 and we obtained an AUC of 0.8, this means that - 80% of the time - the random observation from the first group would be greater than a random observation from the second group by 2 or more. Again, AUCs below 0.5 cannot be interpreted as downregulation, as it may be caused by a positive log-fold change that is less than the threshold.</p>
<h1><a class="anchor" id="summary"></a>
Summary statistics</h1>
<p >The choice of summary statistic dictates the interpretation of the ranking. Given a group X:</p>
<ul>
<li>A large mean effect size indicates that the gene is upregulated in X compared to the average of the other groups. A small value indicates that the gene is downregulated in X instead. This is a good general-purpose summary statistic for ranking, usually by decreasing size to obtain upregulated markers in X.</li>
<li>A large median effect size indicates that the gene is upregulated in X compared to most (&gt;50%) other groups. A small value indicates that the gene is downregulated in X instead. This is also a good general-purpose summary with the advantage of being more robust to outlier effects (but also the disadvantage of being less sensitive to strong effects in a minority of comparisons).</li>
<li>A large minimum effect size indicates that the gene is upregulated in X compared to all other groups. A small value indicates that the gene is downregulated in X compared to at least one other group. For upregulation, this is the most stringent summary as markers will only have extreme values if they are <em>uniquely</em> upregulated in X compared to every other group. However, it may not be effective if X is closely related to any of the groups.</li>
<li>A large maximum effect size indicates that the gene is upregulated in X compared to at least one other group. A small value indicates that the gene is downregulated in X compared to all other groups. For downregulation, this is the most stringent summary as markers will only have extreme values if they are <em>uniquely</em> downregulated in X compared to every other group. However, it may not be effective if X is closely related to any of the groups.</li>
<li>The "minimum rank" (a.k.a. min-rank) is defined by ranking genes based on decreasing effect size <em>within</em> each comparison, and then taking the smallest rank <em>across</em> comparisons. A minimum rank of 1 means that the gene is the top upregulated gene in at least one comparison to another group. More generally, a minimum rank of T indicates that the gene is the T-th upregulated gene in at least one comparison. Applying a threshold on the minimum rank is useful for obtaining a set of genes that, in combination, are guaranteed to distinguish X from every other group.</li>
</ul>
<p >The exact definition of "large" and "small" depends on the choice of effect size. For Cohen's d, LFC and delta-detected, the value must be positive to be considered "large", and negative to be considered "small". For the AUC, a value greater than 0.5 is considered "large" and less than 0.5 is considered "small". Note that this interpretation is contingent on the log-fold change threshold - for positive thresholds, small effects cannot be unambiguously interpreted as downregulation.</p>
<h1><a class="anchor" id="blocked"></a>
Blocked comparisons</h1>
<p >In the presence of multiple batches, we can block on the batch of origin for each cell. Comparisons are only performed between the groups of cells in the same batch (also called "blocking level" below). The batch-specific effect sizes are then combined into a single aggregate value for calculation of summary statistics. This strategy avoids most problems related to batch effects as we never directly compare across different blocking levels.</p>
<p >Specifically, for each gene and each pair of groups, we obtain one effect size per blocking level. We consolidate these into a single statistic by computing the weighted mean across levels. The weight for each level is defined as the product of the sizes of the two groups; this favors contribution from levels with more cells in both groups, where the effect size is presumably more reliable. (Obviously, levels with no cells in either group will not contribute anything to the weighted mean.)</p>
<p >If two groups never co-occur in the same blocking level, no effect size will be computed. We do not attempt to reconcile batch effects in a partially confounded scenario. As such, this particular pair of groups will not contribute to the calculation of the summary statistics for either group.</p>
<h1><a class="anchor" id="other"></a>
Other statistics</h1>
<p >We report the mean log-expression of all cells in each group, as well as the proportion of cells with detectable expression in each group. These statistics are useful for quickly interpreting the differences in expression driving the effect size summaries.</p>
<p >If blocking is involved, we compute the mean and proportion for each group in each separate blocking level. This is helpful for detecting differences in expression between batches. They can also be combined into a single statistic for each group by using the <code><a class="el" href="average__vectors_8hpp.html#a1ad83ffd5170468e5c4ec082605f79e7">average_vectors()</a></code> or <code><a class="el" href="average__vectors_8hpp.html#a0f0c8d5308d416b2d1f516691ee362ef">average_vectors_weighted()</a></code> functions. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a836ea0c31fa496f274943e79035314b5" name="a836ea0c31fa496f274943e79035314b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836ea0c31fa496f274943e79035314b5">&#9670;&nbsp;</a></span>ComputeSummaries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::array&lt;bool, differential_analysis::n_summaries&gt; <a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">scran::ScoreMarkers::ComputeSummaries</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Array type indicating whether each summary statistic should be computed. Each entry corresponds to a summary statistic enumerated in <code>differential_analysis::summary</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a92c1f66cb31e0fba3440164600c72ede" name="a92c1f66cb31e0fba3440164600c72ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c1f66cb31e0fba3440164600c72ede">&#9670;&nbsp;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat  = double, class MAT , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt; scran::ScoreMarkers::run </td>
          <td>(</td>
          <td class="paramtype">const MAT *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code> object containing the summary statistics and the other per-group statistics. Whether particular statistics are computed depends on the configuration from <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related setters. </dd></dl>

</div>
</div>
<a id="afbd8272701d34277064610f6ad9dd90b" name="afbd8272701d34277064610f6ad9dd90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd8272701d34277064610f6ad9dd90b">&#9670;&nbsp;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::ScoreMarkers::run </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>cohen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>auc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>lfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>delta_detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Pointers to arrays of length equal to the number of rows in <code>p</code>, used to store the mean expression of each group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Pointers to arrays of length equal to the number of rows in <code>p</code>, used to store the proportion of detected expression in each group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cohen</td><td>Vector of vector of pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a summary statistic for Cohen's d, ordered as in <code>differential_analysis::summary</code>. Each pointer corresponds to a group and is filled with the relevant summary statistic for that group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the AUC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lfc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the log-fold change instead of Cohen's d. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta_detected</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the delta in the detected proportions.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>cohen</code> is of length 0, Cohen's d is not computed. If any of the inner vectors are of length 0, the corresponding summary statistic is not computed. The same applies to <code>auc</code>, <code>lfc</code> and <code>delta_detected</code>. (<code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related functions have no effect here.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>means</code>, <code>detected</code>, <code>cohen</code> and <code>auc</code> are filled with their corresponding statistics on output. </dd></dl>

</div>
</div>
<a id="aa8995f7687e95134e1728fb7c5183be6" name="aa8995f7687e95134e1728fb7c5183be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8995f7687e95134e1728fb7c5183be6">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat  = double, class MAT , typename G , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt; scran::ScoreMarkers::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const MAT *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups in multiple blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the blocking factor. Levels should be 0-based and consecutive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code> object containing the summary statistics and the other per-group statistics. Whether particular statistics are computed depends on the configuration from <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related setters. </dd></dl>

</div>
</div>
<a id="a5a4ffd18f162583602f9caf3559235c0" name="a5a4ffd18f162583602f9caf3559235c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4ffd18f162583602f9caf3559235c0">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename B , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::ScoreMarkers::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>cohen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>auc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>lfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>delta_detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups in multiple blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the blocking factor. Levels should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Vector of vectors of pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a group and each pointer therein contains the mean expression in a blocking level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a group and each pointer therein contains the proportion of detected expression in a blocking level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cohen</td><td>Vector of vector of pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a summary statistic for Cohen's d, ordered as in <code>differential_analysis::summary</code>. Each pointer corresponds to a group and is filled with the relevant summary statistic for that group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the AUC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lfc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the log-fold change instead of Cohen's d. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta_detected</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the delta in the detected proportions.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>cohen</code> is of length 0, Cohen's d is not computed. If any of the inner vectors are of length 0, the corresponding summary statistic is not computed. The same applies to <code>auc</code>, <code>lfc</code> and <code>delta_detected</code>. (<code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related functions have no effect here.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>means</code>, <code>detected</code>, <code>cohen</code> and <code>auc</code> are filled with their corresponding statistics on output. </dd></dl>

</div>
</div>
<a id="aa33b7936392e32122febd819b8b5b7de" name="aa33b7936392e32122febd819b8b5b7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33b7936392e32122febd819b8b5b7de">&#9670;&nbsp;</a></span>set_compute_auc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_auc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the AUC at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a79b4328dcdd409b2c7156410a9cf1b93">set_compute_auc()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a79b4328dcdd409b2c7156410a9cf1b93" name="a79b4328dcdd409b2c7156410a9cf1b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b4328dcdd409b2c7156410a9cf1b93">&#9670;&nbsp;</a></span>set_compute_auc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_auc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for the AUC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a8a05963063e92a4ac296dfa627de4503" name="a8a05963063e92a4ac296dfa627de4503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a05963063e92a4ac296dfa627de4503">&#9670;&nbsp;</a></span>set_compute_auc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_auc </td>
          <td>(</td>
          <td class="paramtype">differential_analysis::summary&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for the AUC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="accd5fd4f1b273131eb9bce7b59d0eb63" name="accd5fd4f1b273131eb9bce7b59d0eb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd5fd4f1b273131eb9bce7b59d0eb63">&#9670;&nbsp;</a></span>set_compute_cohen() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_cohen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute Cohen's d at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="acc06d8f9005175502e8ff56a55dd4a7d" name="acc06d8f9005175502e8ff56a55dd4a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc06d8f9005175502e8ff56a55dd4a7d">&#9670;&nbsp;</a></span>set_compute_cohen() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_cohen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for Cohen's d.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ae552e125db5264ab1719cf12fdc318fe" name="ae552e125db5264ab1719cf12fdc318fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae552e125db5264ab1719cf12fdc318fe">&#9670;&nbsp;</a></span>set_compute_cohen() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_cohen </td>
          <td>(</td>
          <td class="paramtype">differential_analysis::summary&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for Cohen's d.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a09fba4be4aae73861a38e82727519d4e" name="a09fba4be4aae73861a38e82727519d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fba4be4aae73861a38e82727519d4e">&#9670;&nbsp;</a></span>set_compute_delta_detected() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_delta_detected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the delta detected at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a1220483b8d4b740ead9bca8c70fa2362">set_compute_delta_detected()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a1220483b8d4b740ead9bca8c70fa2362" name="a1220483b8d4b740ead9bca8c70fa2362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1220483b8d4b740ead9bca8c70fa2362">&#9670;&nbsp;</a></span>set_compute_delta_detected() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_delta_detected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for the delta detected.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a519f725507ea407f7fd2a98dfc2f98c2" name="a519f725507ea407f7fd2a98dfc2f98c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519f725507ea407f7fd2a98dfc2f98c2">&#9670;&nbsp;</a></span>set_compute_delta_detected() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_delta_detected </td>
          <td>(</td>
          <td class="paramtype">differential_analysis::summary&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for the delta detected.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a5763df3dc998e92712f2fd8add1edf66" name="a5763df3dc998e92712f2fd8add1edf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5763df3dc998e92712f2fd8add1edf66">&#9670;&nbsp;</a></span>set_compute_lfc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_lfc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the LFC at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#aa8f0dfe45359d007ef9ae492d7e5571c">set_compute_lfc()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="aa8f0dfe45359d007ef9ae492d7e5571c" name="aa8f0dfe45359d007ef9ae492d7e5571c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f0dfe45359d007ef9ae492d7e5571c">&#9670;&nbsp;</a></span>set_compute_lfc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_lfc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for the LFC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a8dd093b0bedf7e9b8d6d81903778ea7a" name="a8dd093b0bedf7e9b8d6d81903778ea7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd093b0bedf7e9b8d6d81903778ea7a">&#9670;&nbsp;</a></span>set_compute_lfc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_lfc </td>
          <td>(</td>
          <td class="paramtype">differential_analysis::summary&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for the LFC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ab3379a274da6d5edfcef09e18191e553" name="ab3379a274da6d5edfcef09e18191e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3379a274da6d5edfcef09e18191e553">&#9670;&nbsp;</a></span>set_summary_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_max </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the maximum summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the maximum from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ab83ea5de6bc23dcb6e73a5c97b62babf" name="ab83ea5de6bc23dcb6e73a5c97b62babf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83ea5de6bc23dcb6e73a5c97b62babf">&#9670;&nbsp;</a></span>set_summary_mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_mean </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the mean summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the mean from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ae3a45151048b3aec1ab7c076470e20b5" name="ae3a45151048b3aec1ab7c076470e20b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a45151048b3aec1ab7c076470e20b5">&#9670;&nbsp;</a></span>set_summary_median()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_median </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the median summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the median from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a9da89baba3b8b60aa87530b81ec8fe9e" name="a9da89baba3b8b60aa87530b81ec8fe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da89baba3b8b60aa87530b81ec8fe9e">&#9670;&nbsp;</a></span>set_summary_min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_min </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the minimum summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the minimum from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a4eefc84e9355d6d45d24a6a35aea2777" name="a4eefc84e9355d6d45d24a6a35aea2777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eefc84e9355d6d45d24a6a35aea2777">&#9670;&nbsp;</a></span>set_summary_min_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_min_rank </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the minimum rank summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the minimum rank from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#afbd8272701d34277064610f6ad9dd90b">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a9e7f5ec97f4628bdb2a6739670614401" name="a9e7f5ec97f4628bdb2a6739670614401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7f5ec97f4628bdb2a6739670614401">&#9670;&nbsp;</a></span>set_threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#ac1138a7ec0df83d0af5d43af9bf7f14b">Defaults::threshold</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Threshold on the log-fold change. This should be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/differential_analysis/<a class="el" href="ScoreMarkers_8hpp_source.html">ScoreMarkers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
