<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::PairwiseEffects Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1PairwiseEffects-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::PairwiseEffects Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Compute pairwise effect size between groups of cells.  
 <a href="classscran_1_1PairwiseEffects.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PairwiseEffects_8hpp_source.html">PairwiseEffects.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1PairwiseEffects_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pairwise effect size results.  <a href="structscran_1_1PairwiseEffects_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html">ResultsWithMeans</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pairwise effect size results, with per-group means.  <a href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a274b56d1255fece348c29f6acf511168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a274b56d1255fece348c29f6acf511168">set_threshold</a> (double t=<a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a4e73a03cee22b6ee5f949fcdf4500b46">Defaults::threshold</a>)</td></tr>
<tr class="separator:a274b56d1255fece348c29f6acf511168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad75a6f74edb5a45914e60eaa487fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#aaad75a6f74edb5a45914e60eaa487fb5">set_num_threads</a> (int n=<a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a03a1691771c655ac21eb7b282123e282">Defaults::num_threads</a>)</td></tr>
<tr class="separator:aaad75a6f74edb5a45914e60eaa487fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8502150c4ebec6bf8e13e6f7ef85b105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a8502150c4ebec6bf8e13e6f7ef85b105">set_compute_cohen</a> (bool c=<a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a8a0050d343bc8b2eec80ce51982f6945">Defaults::compute_cohen</a>)</td></tr>
<tr class="separator:a8502150c4ebec6bf8e13e6f7ef85b105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03200aae7ecd4a67af7172d2e13f0618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a03200aae7ecd4a67af7172d2e13f0618">set_compute_auc</a> (bool c=<a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a909d4dc272c6ac0bec6069f5559b1962">Defaults::compute_auc</a>)</td></tr>
<tr class="separator:a03200aae7ecd4a67af7172d2e13f0618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ccf66ce778baa44e0ec226b9b469e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a84ccf66ce778baa44e0ec226b9b469e3">set_compute_lfc</a> (bool c=<a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#ad9a3f0f122ec6f4ab5654c691d3a8af7">Defaults::compute_lfc</a>)</td></tr>
<tr class="separator:a84ccf66ce778baa44e0ec226b9b469e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f6c3655e8abfb22092ca858bcd396f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#ad0f6c3655e8abfb22092ca858bcd396f">set_compute_delta_detected</a> (bool c=<a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#aed4f78128bfe84cd267010020a2c4f24">Defaults::compute_delta_detected</a>)</td></tr>
<tr class="separator:ad0f6c3655e8abfb22092ca858bcd396f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0097cc273de24f2159a640d2fe5de599"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename Stat &gt; </td></tr>
<tr class="memitem:a0097cc273de24f2159a640d2fe5de599"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a0097cc273de24f2159a640d2fe5de599">run</a> (const Matrix *p, const G *group, std::vector&lt; Stat * &gt; means, std::vector&lt; Stat * &gt; detected, Stat *cohen, Stat *auc, Stat *lfc, Stat *delta_detected) const</td></tr>
<tr class="separator:a0097cc273de24f2159a640d2fe5de599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6787b3f65adb4dd75918afcd962014a"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename B , typename Stat &gt; </td></tr>
<tr class="memitem:ae6787b3f65adb4dd75918afcd962014a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#ae6787b3f65adb4dd75918afcd962014a">run_blocked</a> (const Matrix *p, const G *group, const B *block, std::vector&lt; std::vector&lt; Stat * &gt; &gt; means, std::vector&lt; std::vector&lt; Stat * &gt; &gt; detected, Stat *cohen, Stat *auc, Stat *lfc, Stat *delta_detected) const</td></tr>
<tr class="separator:ae6787b3f65adb4dd75918afcd962014a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8566c457054312c813bf25a7293eb61b"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename Stat &gt; </td></tr>
<tr class="memitem:a8566c457054312c813bf25a7293eb61b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html">Results</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a8566c457054312c813bf25a7293eb61b">run</a> (const Matrix *p, const G *group, std::vector&lt; Stat * &gt; means, std::vector&lt; Stat * &gt; detected) const</td></tr>
<tr class="separator:a8566c457054312c813bf25a7293eb61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbb15cec4a1c39c2e70167099866589"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename B , typename Stat &gt; </td></tr>
<tr class="memitem:a0dbb15cec4a1c39c2e70167099866589"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html">Results</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a0dbb15cec4a1c39c2e70167099866589">run_blocked</a> (const Matrix *p, const G *group, const B *block, std::vector&lt; std::vector&lt; Stat * &gt; &gt; means, std::vector&lt; std::vector&lt; Stat * &gt; &gt; detected) const</td></tr>
<tr class="separator:a0dbb15cec4a1c39c2e70167099866589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a460a12027c532c1e615af44284996"><td class="memTemplParams" colspan="2">template&lt;typename Stat  = double, class Matrix , typename G &gt; </td></tr>
<tr class="memitem:ab3a460a12027c532c1e615af44284996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html">ResultsWithMeans</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#ab3a460a12027c532c1e615af44284996">run</a> (const Matrix *p, const G *group)</td></tr>
<tr class="separator:ab3a460a12027c532c1e615af44284996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073bf2e693a1ba06c2f78d0c2ab3ebe"><td class="memTemplParams" colspan="2">template&lt;typename Stat  = double, class Matrix , typename G , typename B &gt; </td></tr>
<tr class="memitem:a3073bf2e693a1ba06c2f78d0c2ab3ebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html">ResultsWithMeans</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PairwiseEffects.html#a3073bf2e693a1ba06c2f78d0c2ab3ebe">run_blocked</a> (const Matrix *p, const G *group, const B *block)</td></tr>
<tr class="separator:a3073bf2e693a1ba06c2f78d0c2ab3ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compute pairwise effect size between groups of cells. </p>
<p>This class computes the effect sizes for the pairwise comparisons used in <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code>, prior to any ranking of marker genes. It may be desirable to call this function directly if the pairwise effects themselves are of interest, rather than per-group summaries.</p>
<h1><a class="anchor" id="effect-sizes"></a>
Choice of effect sizes</h1>
<p>The log-fold change (LFC) is the difference in the mean log-expression between groups. This is fairly straightforward to interpret - as log-fold change of +1 corresponds to a two-fold upregulation in the first group compared to the second. For this interpretation, we assume that the input matrix contains log-transformed normalized expression values.</p>
<p>The delta-detected is the difference in the proportion of cells with detected expression between groups. This lies between 1 and -1, with the extremes occurring when a gene is silent in one group and detected in all cells of the other group. For this interpretation, we assume that the input matrix contains non-negative expression values, where a value of zero corresponds to lack of detectable expression.</p>
<p>Cohen's d is the standardized log-fold change between two groups. This is defined as the difference in the mean log-expression for each group scaled by the average standard deviation across the two groups. (Technically, we should use the pooled variance; however, this introduces some unpleasant asymmetry depending on the variance of the larger group, so we take a simple average instead.) A positive value indicates that the gene is upregulated in the first gene compared to the second. Cohen's d is analogous to the t-statistic in a two-sample t-test and avoids spuriously large effect sizes from comparisons between highly variable groups. We can also interpret Cohen's d as the number of standard deviations between the two group means.</p>
<p>The area under the curve (AUC) can be interpreted as the probability that a randomly chosen observation in one group is greater than a randomly chosen observation in the other group. Values greater than 0.5 indicate that a gene is upregulated in the first group. The AUC is closely related to the U-statistic used in the Wilcoxon rank sum test. The key difference between the AUC and Cohen's d is that the former is less sensitive to the variance within each group, e.g., if two distributions exhibit no overlap, the AUC is the same regardless of the variance of each distribution. This may or may not be desirable as it improves robustness to outliers but reduces the information available to obtain a highly resolved ranking.</p>
<h1><a class="anchor" id="lfc-threshold"></a>
With a log-fold change threshold</h1>
<p>Setting a log-fold change threshold can be helpful as it prioritizes genes with large shifts in expression instead of those with low variances. Currently, only positive thresholds are supported - this focuses on genes upregulated in the first group compared to the second. The effect size definitions are generalized when testing against a non-zero log-fold change threshold.</p>
<p>Cohen's d is redefined as the standardized difference between the observed log-fold change and the specified threshold, analogous to the TREAT method from <b>limma</b>. Large positive values are only obtained when the observed log-fold change is significantly greater than the threshold. For example, if we had a threshold of 2 and we obtained a Cohen's d of 3, this means that the observed log-fold change was 3 standard deviations above 2. Importantly, a negative Cohen's d cannot be intepreted as downregulation, as the log-fold change may still be positive but less than the threshold.</p>
<p>The AUC generalized to the probability of obtaining a random observation in one group that is greater than a random observation plus the threshold in the other group. For example, if we had a threshold of 2 and we obtained an AUC of 0.8, this means that - 80% of the time - the random observation from the first group would be greater than a random observation from the second group by 2 or more. Again, AUCs below 0.5 cannot be interpreted as downregulation, as it may be caused by a positive log-fold change that is less than the threshold.</p>
<h1><a class="anchor" id="blocked"></a>
Blocked comparisons</h1>
<p>In the presence of multiple batches, we can block on the batch of origin for each cell. Comparisons are only performed between the groups of cells in the same batch (also called "blocking level" below). The batch-specific effect sizes are then combined into a single aggregate value for output. This strategy avoids most problems related to batch effects as we never directly compare across different blocking levels.</p>
<p>Specifically, for each gene and each pair of groups, we obtain one effect size per blocking level. We consolidate these into a single statistic by computing the weighted mean across levels. The weight for each level is defined as the product of the sizes of the two groups; this favors contribution from levels with more cells in both groups, where the effect size is presumably more reliable. (Obviously, levels with no cells in either group will not contribute anything to the weighted mean.)</p>
<p>If two groups never co-occur in the same blocking level, no effect size will be computed and a <code>NaN</code> is reported in the output. We do not attempt to reconcile batch effects in a partially confounded scenario.</p>
<h1><a class="anchor" id="other"></a>
Other statistics</h1>
<p>We report the mean log-expression of all cells in each group, as well as the proportion of cells with detectable expression in each group. These statistics are useful for quickly interpreting the differences in expression driving the effect size summaries.</p>
<p>If blocking is involved, we compute the mean and proportion for each group in each separate blocking level. This is helpful for detecting differences in expression between batches. They can also be combined into a single statistic for each group by using the <code><a class="el" href="namespacescran.html#a1ad83ffd5170468e5c4ec082605f79e7">average_vectors()</a></code> or <code><a class="el" href="namespacescran.html#a0f0c8d5308d416b2d1f516691ee362ef">average_vectors_weighted()</a></code> functions. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a274b56d1255fece348c29f6acf511168" name="a274b56d1255fece348c29f6acf511168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274b56d1255fece348c29f6acf511168">&#9670;&#160;</a></span>set_threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp; scran::PairwiseEffects::set_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a4e73a03cee22b6ee5f949fcdf4500b46">Defaults::threshold</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Threshold on the log-fold change. This should be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code> object. </dd></dl>

</div>
</div>
<a id="aaad75a6f74edb5a45914e60eaa487fb5" name="aaad75a6f74edb5a45914e60eaa487fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad75a6f74edb5a45914e60eaa487fb5">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp; scran::PairwiseEffects::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a03a1691771c655ac21eb7b282123e282">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code> object. </dd></dl>

</div>
</div>
<a id="a8502150c4ebec6bf8e13e6f7ef85b105" name="a8502150c4ebec6bf8e13e6f7ef85b105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8502150c4ebec6bf8e13e6f7ef85b105">&#9670;&#160;</a></span>set_compute_cohen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp; scran::PairwiseEffects::set_compute_cohen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a8a0050d343bc8b2eec80ce51982f6945">Defaults::compute_cohen</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to compute Cohen's d.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1PairwiseEffects.html#a0097cc273de24f2159a640d2fe5de599">run()</a></code> methods that return <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code> object. </dd></dl>

</div>
</div>
<a id="a03200aae7ecd4a67af7172d2e13f0618" name="a03200aae7ecd4a67af7172d2e13f0618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03200aae7ecd4a67af7172d2e13f0618">&#9670;&#160;</a></span>set_compute_auc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp; scran::PairwiseEffects::set_compute_auc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#a909d4dc272c6ac0bec6069f5559b1962">Defaults::compute_auc</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to compute the AUC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1PairwiseEffects.html#a0097cc273de24f2159a640d2fe5de599">run()</a></code> methods that return <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code> object. </dd></dl>

</div>
</div>
<a id="a84ccf66ce778baa44e0ec226b9b469e3" name="a84ccf66ce778baa44e0ec226b9b469e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ccf66ce778baa44e0ec226b9b469e3">&#9670;&#160;</a></span>set_compute_lfc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp; scran::PairwiseEffects::set_compute_lfc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#ad9a3f0f122ec6f4ab5654c691d3a8af7">Defaults::compute_lfc</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to compute the log-fold change.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1PairwiseEffects.html#a0097cc273de24f2159a640d2fe5de599">run()</a></code> methods that return <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code> object. </dd></dl>

</div>
</div>
<a id="ad0f6c3655e8abfb22092ca858bcd396f" name="ad0f6c3655e8abfb22092ca858bcd396f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f6c3655e8abfb22092ca858bcd396f">&#9670;&#160;</a></span>set_compute_delta_detected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PairwiseEffects.html">PairwiseEffects</a> &amp; scran::PairwiseEffects::set_compute_delta_detected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Defaults.html#aed4f78128bfe84cd267010020a2c4f24">Defaults::compute_delta_detected</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to compute the delta-detected.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1PairwiseEffects.html#a0097cc273de24f2159a640d2fe5de599">run()</a></code> methods that return <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code> object. </dd></dl>

</div>
</div>
<a id="a0097cc273de24f2159a640d2fe5de599" name="a0097cc273de24f2159a640d2fe5de599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0097cc273de24f2159a640d2fe5de599">&#9670;&#160;</a></span>run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::PairwiseEffects::run </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>cohen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>auc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>lfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>delta_detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute effect sizes for pairwise comparisons between groups. On output, <code>means</code>, <code>detected</code>, <code>cohen</code>, <code>auc</code>, <code>lfc</code> and <code>delta_detected</code> are filled with their corresponding statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Vector of length equal to the number of groups. Each element corresponds to a group and is a pointer to an array of length equal to the number of rows in <code>p</code>. This is used to store the mean expression of each group across all genes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Vector of length equal to the number of groups, Each element corresponds to a group and is a pointer to an array of length equal to the number of rows in <code>p</code>. This is used to store the proportion of detected expression in each group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cohen</td><td>Pointer to an array of length equal to $GN^2$, where <code>N</code> is the number of groups and <code>G</code> is the number of genes (see <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code> for details). This is filled with the Cohen's d for the pairwise comparisons between groups across all genes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auc</td><td>Pointer to an array as described for <code>cohen</code>, but instead storing the AUC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lfc</td><td>Pointer to an array as described for <code>cohen</code>, but instead storing the log-fold change. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta_detected</td><td>Pointer to an array as described for <code>cohen</code>, but instead the delta in the detected proportions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6787b3f65adb4dd75918afcd962014a" name="ae6787b3f65adb4dd75918afcd962014a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6787b3f65adb4dd75918afcd962014a">&#9670;&#160;</a></span>run_blocked() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename B , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::PairwiseEffects::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>cohen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>auc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>lfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stat *&#160;</td>
          <td class="paramname"><em>delta_detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute effect sizes for pairwise comparisons between groups, accounting for any blocking factor in the dataset. On output, <code>means</code>, <code>detected</code>, <code>cohen</code>, <code>auc</code>, <code>lfc</code> and <code>delta_detected</code> are filled with their corresponding statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Vector of length equal to the number of groups. Each element corresponds to a group and is another vector of length equal to the number of blocks. Each entry of the inner vector is a pointer to an array of length equal to the number of rows in <code>p</code>, which is used to store the mean expression of each group across all genes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Vector of length equal to the number of groups. Each element corresponds to a group and is another vector of length equal to the number of blocks. Each entry of the inner vector is a pointer to an array of length equal to the number of rows in <code>p</code>, which is used to store the proportion of detected expression in each group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cohen</td><td>Pointer to an array of length equal to $GN^2$, where <code>N</code> is the number of groups and <code>G</code> is the number of genes (see <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code> for details). This is filled with the Cohen's d for the pairwise comparisons between groups across all genes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auc</td><td>Pointer to an array as described for <code>cohen</code>, but instead storing the AUC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lfc</td><td>Pointer to an array as described for <code>cohen</code>, but instead storing the log-fold change. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta_detected</td><td>Pointer to an array as described for <code>cohen</code>, but instead the delta in the detected proportions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8566c457054312c813bf25a7293eb61b" name="a8566c457054312c813bf25a7293eb61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8566c457054312c813bf25a7293eb61b">&#9670;&#160;</a></span>run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html">Results</a>&lt; Stat &gt; scran::PairwiseEffects::run </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score potential marker genes by computing summary statistics across pairwise comparisons between groups.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Vector of length equal to the number of groups. Each element corresponds to a group and is a pointer to an array of length equal to the number of rows in <code>p</code>. This is used to store the mean expression of each group across all genes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Vector of length equal to the number of groups, Each element corresponds to a group and is a pointer to an array of length equal to the number of rows in <code>p</code>. This is used to store the proportion of detected expression in each group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code> object is returned containing the pairwise effects. <code>means</code> and <code>detected</code> are filled with their corresponding statistics on output. </dd></dl>

</div>
</div>
<a id="a0dbb15cec4a1c39c2e70167099866589" name="a0dbb15cec4a1c39c2e70167099866589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbb15cec4a1c39c2e70167099866589">&#9670;&#160;</a></span>run_blocked() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename B , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html">Results</a>&lt; Stat &gt; scran::PairwiseEffects::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score potential marker genes by computing summary statistics across pairwise comparisons between groups in multiple blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Vector of length equal to the number of groups. Each element corresponds to a group and is another vector of length equal to the number of blocks. Each entry of the inner vector is a pointer to an array of length equal to the number of rows in <code>p</code>, which is used to store the mean expression of each group across all genes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Vector of length equal to the number of groups. Each element corresponds to a group and is another vector of length equal to the number of blocks. Each entry of the inner vector is a pointer to an array of length equal to the number of rows in <code>p</code>, which is used to store the proportion of detected expression in each group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PairwiseEffects_1_1Results.html" title="Pairwise effect size results.">Results</a></code> object is returned containing the pairwise effects. <code>means</code> and <code>detected</code> are filled with their corresponding statistics on output. </dd></dl>

</div>
</div>
<a id="ab3a460a12027c532c1e615af44284996" name="ab3a460a12027c532c1e615af44284996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a460a12027c532c1e615af44284996">&#9670;&#160;</a></span>run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat  = double, class Matrix , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html">ResultsWithMeans</a>&lt; Stat &gt; scran::PairwiseEffects::run </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score potential marker genes by computing summary statistics across pairwise comparisons between groups.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics. </td></tr>
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html" title="Pairwise effect size results, with per-group means.">ResultsWithMeans</a></code> object is returned containing the pairwise effects, plus the mean expression and detected proportion in each group. </dd></dl>

</div>
</div>
<a id="a3073bf2e693a1ba06c2f78d0c2ab3ebe" name="a3073bf2e693a1ba06c2f78d0c2ab3ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073bf2e693a1ba06c2f78d0c2ab3ebe">&#9670;&#160;</a></span>run_blocked() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat  = double, class Matrix , typename G , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html">ResultsWithMeans</a>&lt; Stat &gt; scran::PairwiseEffects::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score potential marker genes by computing summary statistics across pairwise comparisons between groups in multiple blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics. </td></tr>
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type for the block assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in $[0, N)$ where $N$ is the number of unique groups.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PairwiseEffects_1_1ResultsWithMeans.html" title="Pairwise effect size results, with per-group means.">ResultsWithMeans</a></code> object is returned containing the pairwise effects, plus the mean expression and detected proportion in each group and block. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/differential_analysis/<a class="el" href="PairwiseEffects_8hpp_source.html">PairwiseEffects.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
