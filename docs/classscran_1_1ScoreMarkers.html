<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::ScoreMarkers Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1ScoreMarkers-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::ScoreMarkers Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Score each gene as a candidate marker for each group of cells.  
 <a href="classscran_1_1ScoreMarkers.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScoreMarkers_8hpp_source.html">ScoreMarkers.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1ScoreMarkers_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a> of the marker scoring.  <a href="structscran_1_1ScoreMarkers_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a836ea0c31fa496f274943e79035314b5"><td class="memItemLeft" align="right" valign="top">typedef std::array&lt; bool, differential_analysis::n_summaries &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a></td></tr>
<tr class="separator:a836ea0c31fa496f274943e79035314b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e7f5ec97f4628bdb2a6739670614401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a9e7f5ec97f4628bdb2a6739670614401">set_threshold</a> (double t=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#ac1138a7ec0df83d0af5d43af9bf7f14b">Defaults::threshold</a>)</td></tr>
<tr class="separator:a9e7f5ec97f4628bdb2a6739670614401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc06d8f9005175502e8ff56a55dd4a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:acc06d8f9005175502e8ff56a55dd4a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd5fd4f1b273131eb9bce7b59d0eb63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#accd5fd4f1b273131eb9bce7b59d0eb63">set_compute_cohen</a> (bool c)</td></tr>
<tr class="separator:accd5fd4f1b273131eb9bce7b59d0eb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae552e125db5264ab1719cf12fdc318fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ae552e125db5264ab1719cf12fdc318fe">set_compute_cohen</a> (<a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a> s, bool c)</td></tr>
<tr class="separator:ae552e125db5264ab1719cf12fdc318fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b4328dcdd409b2c7156410a9cf1b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a79b4328dcdd409b2c7156410a9cf1b93">set_compute_auc</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:a79b4328dcdd409b2c7156410a9cf1b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33b7936392e32122febd819b8b5b7de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#aa33b7936392e32122febd819b8b5b7de">set_compute_auc</a> (bool c)</td></tr>
<tr class="separator:aa33b7936392e32122febd819b8b5b7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a05963063e92a4ac296dfa627de4503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a8a05963063e92a4ac296dfa627de4503">set_compute_auc</a> (<a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a> s, bool c)</td></tr>
<tr class="separator:a8a05963063e92a4ac296dfa627de4503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f0dfe45359d007ef9ae492d7e5571c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#aa8f0dfe45359d007ef9ae492d7e5571c">set_compute_lfc</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:aa8f0dfe45359d007ef9ae492d7e5571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5763df3dc998e92712f2fd8add1edf66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a5763df3dc998e92712f2fd8add1edf66">set_compute_lfc</a> (bool c)</td></tr>
<tr class="separator:a5763df3dc998e92712f2fd8add1edf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd093b0bedf7e9b8d6d81903778ea7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a8dd093b0bedf7e9b8d6d81903778ea7a">set_compute_lfc</a> (<a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a> s, bool c)</td></tr>
<tr class="separator:a8dd093b0bedf7e9b8d6d81903778ea7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1220483b8d4b740ead9bca8c70fa2362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a1220483b8d4b740ead9bca8c70fa2362">set_compute_delta_detected</a> (<a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a> s=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>())</td></tr>
<tr class="separator:a1220483b8d4b740ead9bca8c70fa2362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fba4be4aae73861a38e82727519d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a09fba4be4aae73861a38e82727519d4e">set_compute_delta_detected</a> (bool c)</td></tr>
<tr class="separator:a09fba4be4aae73861a38e82727519d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519f725507ea407f7fd2a98dfc2f98c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a519f725507ea407f7fd2a98dfc2f98c2">set_compute_delta_detected</a> (<a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a> s, bool c)</td></tr>
<tr class="separator:a519f725507ea407f7fd2a98dfc2f98c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1608e184ef29a0d374f969cdc218ac53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a1608e184ef29a0d374f969cdc218ac53">set_num_threads</a> (int n=<a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a5239f3c203cf47a7ca4abd3fda851242">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a1608e184ef29a0d374f969cdc218ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da89baba3b8b60aa87530b81ec8fe9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a9da89baba3b8b60aa87530b81ec8fe9e">set_summary_min</a> (bool s)</td></tr>
<tr class="separator:a9da89baba3b8b60aa87530b81ec8fe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83ea5de6bc23dcb6e73a5c97b62babf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ab83ea5de6bc23dcb6e73a5c97b62babf">set_summary_mean</a> (bool s)</td></tr>
<tr class="separator:ab83ea5de6bc23dcb6e73a5c97b62babf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a45151048b3aec1ab7c076470e20b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ae3a45151048b3aec1ab7c076470e20b5">set_summary_median</a> (bool s)</td></tr>
<tr class="separator:ae3a45151048b3aec1ab7c076470e20b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3379a274da6d5edfcef09e18191e553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ab3379a274da6d5edfcef09e18191e553">set_summary_max</a> (bool s)</td></tr>
<tr class="separator:ab3379a274da6d5edfcef09e18191e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eefc84e9355d6d45d24a6a35aea2777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a4eefc84e9355d6d45d24a6a35aea2777">set_summary_min_rank</a> (bool s)</td></tr>
<tr class="separator:a4eefc84e9355d6d45d24a6a35aea2777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d56c9db569b81ac49429fa9af4c4a41"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename Stat &gt; </td></tr>
<tr class="memitem:a0d56c9db569b81ac49429fa9af4c4a41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run</a> (const Matrix *p, const G *group, std::vector&lt; Stat * &gt; means, std::vector&lt; Stat * &gt; detected, std::vector&lt; std::vector&lt; Stat * &gt; &gt; cohen, std::vector&lt; std::vector&lt; Stat * &gt; &gt; auc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; lfc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; delta_detected) const</td></tr>
<tr class="separator:a0d56c9db569b81ac49429fa9af4c4a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d319660600b0cd24724b56e7ca6a4f5"><td class="memTemplParams" colspan="2">template&lt;class Matrix , typename G , typename B , typename Stat &gt; </td></tr>
<tr class="memitem:a9d319660600b0cd24724b56e7ca6a4f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a9d319660600b0cd24724b56e7ca6a4f5">run_blocked</a> (const Matrix *p, const G *group, const B *block, std::vector&lt; std::vector&lt; Stat * &gt; &gt; means, std::vector&lt; std::vector&lt; Stat * &gt; &gt; detected, std::vector&lt; std::vector&lt; Stat * &gt; &gt; cohen, std::vector&lt; std::vector&lt; Stat * &gt; &gt; auc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; lfc, std::vector&lt; std::vector&lt; Stat * &gt; &gt; delta_detected) const</td></tr>
<tr class="separator:a9d319660600b0cd24724b56e7ca6a4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c81526daaefc33a903e6339e4e57d2e"><td class="memTemplParams" colspan="2">template&lt;typename Stat  = double, class MAT , typename G &gt; </td></tr>
<tr class="memitem:a5c81526daaefc33a903e6339e4e57d2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#a5c81526daaefc33a903e6339e4e57d2e">run</a> (const MAT *p, const G *group) const</td></tr>
<tr class="separator:a5c81526daaefc33a903e6339e4e57d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f2036ba33acaca3056557f77dbebb6"><td class="memTemplParams" colspan="2">template&lt;typename Stat  = double, class MAT , typename G , typename B &gt; </td></tr>
<tr class="memitem:ae9f2036ba33acaca3056557f77dbebb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreMarkers.html#ae9f2036ba33acaca3056557f77dbebb6">run_blocked</a> (const MAT *p, const G *group, const B *block) const</td></tr>
<tr class="separator:ae9f2036ba33acaca3056557f77dbebb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Score each gene as a candidate marker for each group of cells. </p>
<p >Markers are identified by differential expression analyses between pairs of groups of cells (e.g., clusters, cell types). Given <code>n</code> groups, each group is involved in <code>n - 1</code> pairwise comparisons and thus has <code>n - 1</code> effect sizes. For each group, we compute summary statistics - e.g., median, mean - of the effect sizes across all of that group's comparisons. Users can then sort by any of these summaries to obtain a ranking of potential marker genes for each group.</p>
<p >The choice of effect size and summary statistic determines the characteristics of the resulting marker set. For the effect sizes: we compute Cohen's d, the area under the curve (AUC), the log-fold change and the delta-detected, which are described in more detail in the documentation for <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code>, For the summary statistics: we compute the minimum, mean, median, maximum and min-rank of the effect sizes across each group's pairwise comparisons, which are described in <code><a class="el" href="classscran_1_1SummarizeEffects.html" title="Summarize pairwise effects into summary statistics per group.">SummarizeEffects</a></code>.</p>
<p >If the dataset contains blocking factors such as batch or sample, we compute the effect size within each level of the blocking factor. This avoids interference from batch effects or sample-to-sample variation. Users can also adjust the effect size to account for a minimum log-fold change threshold, in order to focus on markers with larger changes in expression. See <code><a class="el" href="classscran_1_1PairwiseEffects.html" title="Compute pairwise effect size between groups of cells.">PairwiseEffects</a></code> for more details.</p>
<p >As a courtesy, we also compute the mean expression a </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a836ea0c31fa496f274943e79035314b5" name="a836ea0c31fa496f274943e79035314b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836ea0c31fa496f274943e79035314b5">&#9670;&#160;</a></span>ComputeSummaries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::array&lt;bool, differential_analysis::n_summaries&gt; <a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">scran::ScoreMarkers::ComputeSummaries</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Array type indicating whether each summary statistic should be computed. Each entry corresponds to a summary statistic enumerated in <code><a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5c81526daaefc33a903e6339e4e57d2e" name="a5c81526daaefc33a903e6339e4e57d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c81526daaefc33a903e6339e4e57d2e">&#9670;&#160;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat  = double, class MAT , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt; scran::ScoreMarkers::run </td>
          <td>(</td>
          <td class="paramtype">const MAT *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code> object containing the summary statistics and the other per-group statistics. Whether particular statistics are computed depends on the configuration from <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related setters. </dd></dl>

</div>
</div>
<a id="a0d56c9db569b81ac49429fa9af4c4a41" name="a0d56c9db569b81ac49429fa9af4c4a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d56c9db569b81ac49429fa9af4c4a41">&#9670;&#160;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::ScoreMarkers::run </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Stat * &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>cohen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>auc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>lfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>delta_detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Pointers to arrays of length equal to the number of rows in <code>p</code>, used to store the mean expression of each group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Pointers to arrays of length equal to the number of rows in <code>p</code>, used to store the proportion of detected expression in each group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cohen</td><td>Vector of vector of pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a summary statistic for Cohen's d, ordered as in <code><a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a></code>. Each pointer corresponds to a group and is filled with the relevant summary statistic for that group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the AUC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lfc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the log-fold change instead of Cohen's d. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta_detected</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the delta in the detected proportions.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>cohen</code> is of length 0, Cohen's d is not computed. If any of the inner vectors are of length 0, the corresponding summary statistic is not computed. The same applies to <code>auc</code>, <code>lfc</code> and <code>delta_detected</code>. (<code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related functions have no effect here.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>means</code>, <code>detected</code>, <code>cohen</code> and <code>auc</code> are filled with their corresponding statistics on output. </dd></dl>

</div>
</div>
<a id="ae9f2036ba33acaca3056557f77dbebb6" name="ae9f2036ba33acaca3056557f77dbebb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f2036ba33acaca3056557f77dbebb6">&#9670;&#160;</a></span>run_blocked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat  = double, class MAT , typename G , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html">Results</a>&lt; Stat &gt; scran::ScoreMarkers::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const MAT *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups in multiple blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the blocking factor. Levels should be 0-based and consecutive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code> object containing the summary statistics and the other per-group statistics. Whether particular statistics are computed depends on the configuration from <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related setters. </dd></dl>

</div>
</div>
<a id="a9d319660600b0cd24724b56e7ca6a4f5" name="a9d319660600b0cd24724b56e7ca6a4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d319660600b0cd24724b56e7ca6a4f5">&#9670;&#160;</a></span>run_blocked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , typename G , typename B , typename Stat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::ScoreMarkers::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const Matrix *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const G *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>means</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>cohen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>auc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>lfc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Stat * &gt; &gt;&#160;</td>
          <td class="paramname"><em>delta_detected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Score potential marker genes by computing summary statistics across pairwise comparisons between groups in multiple blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Matrix</td><td>A <b>tatami</b> matrix class, usually a <code>NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">G</td><td>Integer type for the group assignments. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating-point type to store the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>Pointer to a <b>tatami</b> matrix instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the group assignments. These should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>p</code>, containing the blocking factor. Levels should be 0-based and consecutive. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">means</td><td>Vector of vectors of pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a group and each pointer therein contains the mean expression in a blocking level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detected</td><td>Pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a group and each pointer therein contains the proportion of detected expression in a blocking level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cohen</td><td>Vector of vector of pointers to arrays of length equal to the number of rows in <code>p</code>. Each inner vector corresponds to a summary statistic for Cohen's d, ordered as in <code><a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a></code>. Each pointer corresponds to a group and is filled with the relevant summary statistic for that group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">auc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the AUC. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lfc</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the log-fold change instead of Cohen's d. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delta_detected</td><td>Vector of vector of pointers as described for <code>cohen</code>, but instead storing summary statistics for the delta in the detected proportions.</td></tr>
  </table>
  </dd>
</dl>
<p>If <code>cohen</code> is of length 0, Cohen's d is not computed. If any of the inner vectors are of length 0, the corresponding summary statistic is not computed. The same applies to <code>auc</code>, <code>lfc</code> and <code>delta_detected</code>. (<code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> and related functions have no effect here.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>means</code>, <code>detected</code>, <code>cohen</code> and <code>auc</code> are filled with their corresponding statistics on output. </dd></dl>

</div>
</div>
<a id="aa33b7936392e32122febd819b8b5b7de" name="aa33b7936392e32122febd819b8b5b7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33b7936392e32122febd819b8b5b7de">&#9670;&#160;</a></span>set_compute_auc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_auc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the AUC at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a79b4328dcdd409b2c7156410a9cf1b93">set_compute_auc()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a79b4328dcdd409b2c7156410a9cf1b93" name="a79b4328dcdd409b2c7156410a9cf1b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b4328dcdd409b2c7156410a9cf1b93">&#9670;&#160;</a></span>set_compute_auc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_auc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for the AUC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a8a05963063e92a4ac296dfa627de4503" name="a8a05963063e92a4ac296dfa627de4503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a05963063e92a4ac296dfa627de4503">&#9670;&#160;</a></span>set_compute_auc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_auc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for the AUC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="accd5fd4f1b273131eb9bce7b59d0eb63" name="accd5fd4f1b273131eb9bce7b59d0eb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd5fd4f1b273131eb9bce7b59d0eb63">&#9670;&#160;</a></span>set_compute_cohen() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_cohen </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute Cohen's d at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="acc06d8f9005175502e8ff56a55dd4a7d" name="acc06d8f9005175502e8ff56a55dd4a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc06d8f9005175502e8ff56a55dd4a7d">&#9670;&#160;</a></span>set_compute_cohen() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_cohen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for Cohen's d.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ae552e125db5264ab1719cf12fdc318fe" name="ae552e125db5264ab1719cf12fdc318fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae552e125db5264ab1719cf12fdc318fe">&#9670;&#160;</a></span>set_compute_cohen() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_cohen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for Cohen's d.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a09fba4be4aae73861a38e82727519d4e" name="a09fba4be4aae73861a38e82727519d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fba4be4aae73861a38e82727519d4e">&#9670;&#160;</a></span>set_compute_delta_detected() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_delta_detected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the delta detected at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a1220483b8d4b740ead9bca8c70fa2362">set_compute_delta_detected()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a1220483b8d4b740ead9bca8c70fa2362" name="a1220483b8d4b740ead9bca8c70fa2362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1220483b8d4b740ead9bca8c70fa2362">&#9670;&#160;</a></span>set_compute_delta_detected() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_delta_detected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for the delta detected.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a519f725507ea407f7fd2a98dfc2f98c2" name="a519f725507ea407f7fd2a98dfc2f98c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519f725507ea407f7fd2a98dfc2f98c2">&#9670;&#160;</a></span>set_compute_delta_detected() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_delta_detected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for the delta detected.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a5763df3dc998e92712f2fd8add1edf66" name="a5763df3dc998e92712f2fd8add1edf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5763df3dc998e92712f2fd8add1edf66">&#9670;&#160;</a></span>set_compute_lfc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_lfc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the LFC at all.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an alias for <code><a class="el" href="classscran_1_1ScoreMarkers.html#aa8f0dfe45359d007ef9ae492d7e5571c">set_compute_lfc()</a></code> where <code>c = true</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries()</a></code> and <code>c = false</code> is equivalent to <code>s = <a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a2ce7d34d04baed541e958ac5deebfb36">Defaults::compute_no_summaries()</a></code>.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="aa8f0dfe45359d007ef9ae492d7e5571c" name="aa8f0dfe45359d007ef9ae492d7e5571c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f0dfe45359d007ef9ae492d7e5571c">&#9670;&#160;</a></span>set_compute_lfc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_lfc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreMarkers.html#a836ea0c31fa496f274943e79035314b5">ComputeSummaries</a>&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a220fdcc79f6d7c8810eacd29fbf19b09">Defaults::compute_all_summaries</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Which summary statistics to compute for the LFC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a8dd093b0bedf7e9b8d6d81903778ea7a" name="a8dd093b0bedf7e9b8d6d81903778ea7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd093b0bedf7e9b8d6d81903778ea7a">&#9670;&#160;</a></span>set_compute_lfc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_compute_lfc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacescran_1_1differential__analysis.html#a9651cedd1ef5f3c2631ff3d7af955b23">differential_analysis::summary</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A summary statistic of interest. </td></tr>
    <tr><td class="paramname">c</td><td>Whether to compute the summary statistic <code>s</code> for the LFC.</td></tr>
  </table>
  </dd>
</dl>
<p>This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a1608e184ef29a0d374f969cdc218ac53" name="a1608e184ef29a0d374f969cdc218ac53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1608e184ef29a0d374f969cdc218ac53">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#a5239f3c203cf47a7ca4abd3fda851242">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ab3379a274da6d5edfcef09e18191e553" name="ab3379a274da6d5edfcef09e18191e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3379a274da6d5edfcef09e18191e553">&#9670;&#160;</a></span>set_summary_max()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_max </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the maximum summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the maximum from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ab83ea5de6bc23dcb6e73a5c97b62babf" name="ab83ea5de6bc23dcb6e73a5c97b62babf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83ea5de6bc23dcb6e73a5c97b62babf">&#9670;&#160;</a></span>set_summary_mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_mean </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the mean summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the mean from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="ae3a45151048b3aec1ab7c076470e20b5" name="ae3a45151048b3aec1ab7c076470e20b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a45151048b3aec1ab7c076470e20b5">&#9670;&#160;</a></span>set_summary_median()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_median </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the median summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the median from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a9da89baba3b8b60aa87530b81ec8fe9e" name="a9da89baba3b8b60aa87530b81ec8fe9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da89baba3b8b60aa87530b81ec8fe9e">&#9670;&#160;</a></span>set_summary_min()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_min </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the minimum summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the minimum from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a4eefc84e9355d6d45d24a6a35aea2777" name="a4eefc84e9355d6d45d24a6a35aea2777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eefc84e9355d6d45d24a6a35aea2777">&#9670;&#160;</a></span>set_summary_min_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_summary_min_rank </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to compute the minimum rank summary statistic for any effect size.</td></tr>
  </table>
  </dd>
</dl>
<p>This overrides any previous settings for the minimum rank from the effect-size-specific setters, e.g., <code><a class="el" href="classscran_1_1ScoreMarkers.html#acc06d8f9005175502e8ff56a55dd4a7d">set_compute_cohen()</a></code>. However, it can also be overridden by later calls to those setters.</p>
<p >This only has an effect for <code><a class="el" href="classscran_1_1ScoreMarkers.html#a0d56c9db569b81ac49429fa9af4c4a41">run()</a></code> methods that return <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Results.html" title="Results of the marker scoring.">Results</a></code>. Otherwise, we make this decision based on the validity of the input pointers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<a id="a9e7f5ec97f4628bdb2a6739670614401" name="a9e7f5ec97f4628bdb2a6739670614401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7f5ec97f4628bdb2a6739670614401">&#9670;&#160;</a></span>set_threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreMarkers.html">ScoreMarkers</a> &amp; scran::ScoreMarkers::set_threshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structscran_1_1ScoreMarkers_1_1Defaults.html#ac1138a7ec0df83d0af5d43af9bf7f14b">Defaults::threshold</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Threshold on the log-fold change. This should be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreMarkers.html" title="Score each gene as a candidate marker for each group of cells.">ScoreMarkers</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/differential_analysis/<a class="el" href="ScoreMarkers_8hpp_source.html">ScoreMarkers.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
