<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: A C++ library for single-cell data analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">A C++ library for single-cell data analysis </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2README"></a> <img src="https://github.com/LTLA/libscran/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/LTLA/libscran/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/> <a href="https://codecov.io/gh/LTLA/libscran"><img src="https://codecov.io/gh/LTLA/libscran/branch/master/graph/badge.svg?token=CPER7Q7FEH" alt="Codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1>Overview</h1>
<p>The <b>libscran</b> library takes core parts of the <a href="https://github.com/MarioniLab/scran"><b>scran</b></a> Bioconductor package (as well as other useful bits from other packages) and implements them in C++. The idea is to provide a light-weight library that can be easily embedded into other applications without including the entire R/Bioconductor runtime. For example, we can compile <a href="https://github.com/jkanche/scran.js"><b>libscran</b> to WebAssembly</a> to perform single-cell analyses in the browser; or we can wrap <a href="https://github.com/LTLA/scran.chan"><b>libscran</b> into an R package</a> for a minimal-dependency version of the basic Bioconductor single-cell analysis stack. The library itself is compatible with any CMake-based build system and can be turned into a fully header-only library for easy deployment.</p>
<h1>Quick start</h1>
<p>The example below demonstrates how to use <b>libscran</b> to run a standard analysis of single-cell RNA-seq data.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="scran_8hpp.html">scran/scran.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Loading the data from an unzipped MatrixMarket file.</span></div>
<div class="line"><span class="keyword">auto</span> mat = tatami_mtx::load_matrix_from_file&lt;false, double, int&gt;(argv[1]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Filtering out low-quality cells. </span></div>
<div class="line"><span class="keyword">auto</span> qc_res = <a class="code hl_class" href="classscran_1_1PerCellRnaQcMetrics.html">scran::PerCellRnaQcMetrics</a>().<a class="code hl_function" href="classscran_1_1PerCellRnaQcMetrics.html#afc280ca0d50d07bafca97204aec5d58e">run</a>(mat.get(), { <span class="comment">/* mito subset definitions go here */</span> });</div>
<div class="line"><span class="keyword">auto</span> qc_filters = <a class="code hl_class" href="classscran_1_1SuggestRnaQcFilters.html">scran::SuggestRnaQcFilters</a>().<a class="code hl_function" href="classscran_1_1SuggestRnaQcFilters.html#a4fe13f22af3b265a86a1bb4591b698d8">run</a>(qc_res);</div>
<div class="line"><span class="keyword">auto</span> low_quality = qc_filters.<a class="code hl_function" href="structscran_1_1SuggestRnaQcFilters_1_1Thresholds.html#ac11ca51389fcae64d36a24325677393f">filter</a>(qc_res);</div>
<div class="line"><span class="keyword">auto</span> filtered = <a class="code hl_class" href="classscran_1_1FilterCells.html">scran::FilterCells</a>().<a class="code hl_function" href="classscran_1_1FilterCells.html#a5dd2a40d99238d32c20bd069dff7faff">run</a>(mat, low_quality.data());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Computing log-normalized expression values, re-using the total count from the QC step.</span></div>
<div class="line"><span class="keyword">auto</span> size_factors = scran::subset_vector&lt;false&gt;(qc_res.sums, low_quality.data());</div>
<div class="line"><span class="keyword">auto</span> normalized = <a class="code hl_class" href="classscran_1_1LogNormCounts.html">scran::LogNormCounts</a>().<a class="code hl_function" href="classscran_1_1LogNormCounts.html#ae49fea6cb86c25b647606ec7518d8ba6">run</a>(filtered, std::move(size_factors));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Identifying highly variable genes.</span></div>
<div class="line"><span class="keyword">auto</span> var_res = <a class="code hl_class" href="classscran_1_1ModelGeneVar.html">scran::ModelGeneVar</a>().<a class="code hl_function" href="classscran_1_1ModelGeneVar.html#a6032451d3498f053f02c236e7a51261b">run</a>(normalized.get());</div>
<div class="line"><span class="keyword">auto</span> keep = <a class="code hl_class" href="classscran_1_1ChooseHVGs.html">scran::ChooseHVGs</a>().<a class="code hl_function" href="classscran_1_1ChooseHVGs.html#a8485437ec27c1b9d167fd00b38dad235">run</a>(var_res.residuals.size(), var_res.residuals.data());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Performing a PCA on the HVGs.</span></div>
<div class="line"><span class="keywordtype">int</span> npcs = 20;</div>
<div class="line"><span class="keyword">auto</span> pca_res = <a class="code hl_class" href="classscran_1_1SimplePca.html">scran::SimplePca</a>().<a class="code hl_function" href="classscran_1_1SimplePca.html#a5bea514662c9fd85fd59b423b415aae1">set_rank</a>(npcs).<a class="code hl_function" href="classscran_1_1SimplePca.html#a8a4eef007821dbc0cfbddb5909ab33b3">run</a>(normalized.get(), keep.data());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Performing clustering.</span></div>
<div class="line"><span class="keyword">auto</span> graph = <a class="code hl_class" href="classscran_1_1BuildSnnGraph.html">scran::BuildSnnGraph</a>().<a class="code hl_function" href="classscran_1_1BuildSnnGraph.html#ae491f72749e54804144bff07734ca511">run</a>(npcs, pca_res.pcs.cols(), pca_res.pcs.data());</div>
<div class="line"><span class="keyword">auto</span> clust_res = <a class="code hl_class" href="classscran_1_1ClusterSnnGraphMultiLevel.html">scran::ClusterSnnGraphMultiLevel</a>().<a class="code hl_function" href="classscran_1_1ClusterSnnGraphMultiLevel.html#a6a8599a05d15519bcb654ae26c170200">run</a>(graph);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; best_clustering = clust_res.<a class="code hl_variable" href="structscran_1_1ClusterSnnGraphMultiLevel_1_1Results.html#aecd938d9cb99075ed2cbf791ed9609c7">membership</a>[clust_res.max];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Throw in some marker detection.</span></div>
<div class="line"><span class="keyword">auto</span> marker_res = <a class="code hl_class" href="classscran_1_1ScoreMarkers.html">scran::ScoreMarkers</a>().<a class="code hl_function" href="classscran_1_1ScoreMarkers.html#ac694953ab47372abcd2eb51787744727">run</a>(normalized.get(), best_clustering.data());</div>
<div class="ttc" id="aclassscran_1_1BuildSnnGraph_html"><div class="ttname"><a href="classscran_1_1BuildSnnGraph.html">scran::BuildSnnGraph</a></div><div class="ttdoc">Build a shared nearest-neighbor graph with cells as nodes.</div><div class="ttdef"><b>Definition</b> BuildSnnGraph.hpp:54</div></div>
<div class="ttc" id="aclassscran_1_1BuildSnnGraph_html_ae491f72749e54804144bff07734ca511"><div class="ttname"><a href="classscran_1_1BuildSnnGraph.html#ae491f72749e54804144bff07734ca511">scran::BuildSnnGraph::run</a></div><div class="ttdeci">Results run(size_t ndims, size_t ncells, const double *mat) const</div><div class="ttdef"><b>Definition</b> BuildSnnGraph.hpp:177</div></div>
<div class="ttc" id="aclassscran_1_1ChooseHVGs_html"><div class="ttname"><a href="classscran_1_1ChooseHVGs.html">scran::ChooseHVGs</a></div><div class="ttdoc">Choose highly variable genes for downstream analyses.</div><div class="ttdef"><b>Definition</b> ChooseHVGs.hpp:25</div></div>
<div class="ttc" id="aclassscran_1_1ChooseHVGs_html_a8485437ec27c1b9d167fd00b38dad235"><div class="ttname"><a href="classscran_1_1ChooseHVGs.html#a8485437ec27c1b9d167fd00b38dad235">scran::ChooseHVGs::run</a></div><div class="ttdeci">void run(size_t n, const V *statistic, T *output) const</div><div class="ttdef"><b>Definition</b> ChooseHVGs.hpp:68</div></div>
<div class="ttc" id="aclassscran_1_1ClusterSnnGraphMultiLevel_html"><div class="ttname"><a href="classscran_1_1ClusterSnnGraphMultiLevel.html">scran::ClusterSnnGraphMultiLevel</a></div><div class="ttdoc">Multi-level clustering on a shared nearest-neighbor graph.</div><div class="ttdef"><b>Definition</b> ClusterSnnGraph.hpp:28</div></div>
<div class="ttc" id="aclassscran_1_1ClusterSnnGraphMultiLevel_html_a6a8599a05d15519bcb654ae26c170200"><div class="ttname"><a href="classscran_1_1ClusterSnnGraphMultiLevel.html#a6a8599a05d15519bcb654ae26c170200">scran::ClusterSnnGraphMultiLevel::run</a></div><div class="ttdeci">Results run(const BuildSnnGraph::Results &amp;store) const</div><div class="ttdef"><b>Definition</b> ClusterSnnGraph.hpp:112</div></div>
<div class="ttc" id="aclassscran_1_1FilterCells_html"><div class="ttname"><a href="classscran_1_1FilterCells.html">scran::FilterCells</a></div><div class="ttdoc">Filter out low-quality cells.</div><div class="ttdef"><b>Definition</b> FilterCells.hpp:26</div></div>
<div class="ttc" id="aclassscran_1_1FilterCells_html_a5dd2a40d99238d32c20bd069dff7faff"><div class="ttname"><a href="classscran_1_1FilterCells.html#a5dd2a40d99238d32c20bd069dff7faff">scran::FilterCells::run</a></div><div class="ttdeci">std::shared_ptr&lt; MAT &gt; run(std::shared_ptr&lt; MAT &gt; mat, const X *filter)</div><div class="ttdef"><b>Definition</b> FilterCells.hpp:64</div></div>
<div class="ttc" id="aclassscran_1_1LogNormCounts_html"><div class="ttname"><a href="classscran_1_1LogNormCounts.html">scran::LogNormCounts</a></div><div class="ttdoc">Compute log-normalized expression values.</div><div class="ttdef"><b>Definition</b> LogNormCounts.hpp:32</div></div>
<div class="ttc" id="aclassscran_1_1LogNormCounts_html_ae49fea6cb86c25b647606ec7518d8ba6"><div class="ttname"><a href="classscran_1_1LogNormCounts.html#ae49fea6cb86c25b647606ec7518d8ba6">scran::LogNormCounts::run</a></div><div class="ttdeci">std::shared_ptr&lt; MAT &gt; run(std::shared_ptr&lt; MAT &gt; mat, V size_factors) const</div><div class="ttdef"><b>Definition</b> LogNormCounts.hpp:224</div></div>
<div class="ttc" id="aclassscran_1_1ModelGeneVar_html"><div class="ttname"><a href="classscran_1_1ModelGeneVar.html">scran::ModelGeneVar</a></div><div class="ttdoc">Compute and model the per-gene variances in log-expression data.</div><div class="ttdef"><b>Definition</b> ModelGeneVar.hpp:36</div></div>
<div class="ttc" id="aclassscran_1_1ModelGeneVar_html_a6032451d3498f053f02c236e7a51261b"><div class="ttname"><a href="classscran_1_1ModelGeneVar.html#a6032451d3498f053f02c236e7a51261b">scran::ModelGeneVar::run</a></div><div class="ttdeci">void run(const tatami::Matrix&lt; Value_, Index_ &gt; *mat, Stat_ *means, Stat_ *variances, Stat_ *fitted, Stat_ *residuals) const</div><div class="ttdef"><b>Definition</b> ModelGeneVar.hpp:302</div></div>
<div class="ttc" id="aclassscran_1_1PerCellRnaQcMetrics_html"><div class="ttname"><a href="classscran_1_1PerCellRnaQcMetrics.html">scran::PerCellRnaQcMetrics</a></div><div class="ttdoc">Compute typical per-cell quality control metrics from an RNA count matrix.</div><div class="ttdef"><b>Definition</b> PerCellRnaQcMetrics.hpp:39</div></div>
<div class="ttc" id="aclassscran_1_1PerCellRnaQcMetrics_html_afc280ca0d50d07bafca97204aec5d58e"><div class="ttname"><a href="classscran_1_1PerCellRnaQcMetrics.html#afc280ca0d50d07bafca97204aec5d58e">scran::PerCellRnaQcMetrics::run</a></div><div class="ttdeci">void run(const Matrix *mat, const std::vector&lt; Subset &gt; &amp;subsets, Buffers&lt; Float, Integer &gt; &amp;output) const</div><div class="ttdef"><b>Definition</b> PerCellRnaQcMetrics.hpp:105</div></div>
<div class="ttc" id="aclassscran_1_1ScoreMarkers_html"><div class="ttname"><a href="classscran_1_1ScoreMarkers.html">scran::ScoreMarkers</a></div><div class="ttdoc">Score each gene as a candidate marker for each group of cells.</div><div class="ttdef"><b>Definition</b> ScoreMarkers.hpp:231</div></div>
<div class="ttc" id="aclassscran_1_1ScoreMarkers_html_ac694953ab47372abcd2eb51787744727"><div class="ttname"><a href="classscran_1_1ScoreMarkers.html#ac694953ab47372abcd2eb51787744727">scran::ScoreMarkers::run</a></div><div class="ttdeci">void run(const tatami::Matrix&lt; Value_, Index_ &gt; *p, const Group_ *group, std::vector&lt; Stat_ * &gt; means, std::vector&lt; Stat_ * &gt; detected, std::vector&lt; std::vector&lt; Stat_ * &gt; &gt; cohen, std::vector&lt; std::vector&lt; Stat_ * &gt; &gt; auc, std::vector&lt; std::vector&lt; Stat_ * &gt; &gt; lfc, std::vector&lt; std::vector&lt; Stat_ * &gt; &gt; delta_detected) const</div><div class="ttdef"><b>Definition</b> ScoreMarkers.hpp:650</div></div>
<div class="ttc" id="aclassscran_1_1SimplePca_html"><div class="ttname"><a href="classscran_1_1SimplePca.html">scran::SimplePca</a></div><div class="ttdoc">Perform a simple PCA on a gene-cell matrix.</div><div class="ttdef"><b>Definition</b> SimplePca.hpp:33</div></div>
<div class="ttc" id="aclassscran_1_1SimplePca_html_a5bea514662c9fd85fd59b423b415aae1"><div class="ttname"><a href="classscran_1_1SimplePca.html#a5bea514662c9fd85fd59b423b415aae1">scran::SimplePca::set_rank</a></div><div class="ttdeci">SimplePca &amp; set_rank(int r=Defaults::rank)</div><div class="ttdef"><b>Definition</b> SimplePca.hpp:92</div></div>
<div class="ttc" id="aclassscran_1_1SimplePca_html_a8a4eef007821dbc0cfbddb5909ab33b3"><div class="ttname"><a href="classscran_1_1SimplePca.html#a8a4eef007821dbc0cfbddb5909ab33b3">scran::SimplePca::run</a></div><div class="ttdeci">Results run(const tatami::Matrix&lt; T, IDX &gt; *mat) const</div><div class="ttdef"><b>Definition</b> SimplePca.hpp:299</div></div>
<div class="ttc" id="aclassscran_1_1SuggestRnaQcFilters_html"><div class="ttname"><a href="classscran_1_1SuggestRnaQcFilters.html">scran::SuggestRnaQcFilters</a></div><div class="ttdoc">Create filters to identify low-quality cells from RNA-derived QC metrics.</div><div class="ttdef"><b>Definition</b> SuggestRnaQcFilters.hpp:47</div></div>
<div class="ttc" id="aclassscran_1_1SuggestRnaQcFilters_html_a4fe13f22af3b265a86a1bb4591b698d8"><div class="ttname"><a href="classscran_1_1SuggestRnaQcFilters.html#a4fe13f22af3b265a86a1bb4591b698d8">scran::SuggestRnaQcFilters::run</a></div><div class="ttdeci">Thresholds run(size_t n, const PerCellRnaQcMetrics::Buffers&lt; Float, Integer &gt; &amp;buffers) const</div><div class="ttdef"><b>Definition</b> SuggestRnaQcFilters.hpp:277</div></div>
<div class="ttc" id="ascran_8hpp_html"><div class="ttname"><a href="scran_8hpp.html">scran.hpp</a></div><div class="ttdoc">Umbrella header for all libscran functionality.</div></div>
<div class="ttc" id="astructscran_1_1ClusterSnnGraphMultiLevel_1_1Results_html_aecd938d9cb99075ed2cbf791ed9609c7"><div class="ttname"><a href="structscran_1_1ClusterSnnGraphMultiLevel_1_1Results.html#aecd938d9cb99075ed2cbf791ed9609c7">scran::ClusterSnnGraphMultiLevel::Results::membership</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; int &gt; &gt; membership</div><div class="ttdef"><b>Definition</b> ClusterSnnGraph.hpp:96</div></div>
<div class="ttc" id="astructscran_1_1SuggestRnaQcFilters_1_1Thresholds_html_ac11ca51389fcae64d36a24325677393f"><div class="ttname"><a href="structscran_1_1SuggestRnaQcFilters_1_1Thresholds.html#ac11ca51389fcae64d36a24325677393f">scran::SuggestRnaQcFilters::Thresholds::filter</a></div><div class="ttdeci">void filter(size_t n, const PerCellRnaQcMetrics::Buffers&lt; Float, Integer &gt; &amp;buffers, Output *output) const</div><div class="ttdef"><b>Definition</b> SuggestRnaQcFilters.hpp:158</div></div>
</div><!-- fragment --><p>Each class represents a step in the analysis and has tunable parameters, e.g., <code>RunPCA::set_rank</code> to set the number of PCs. See the <a href="https://ltla.github.io/libscran/">reference documentation</a> for more details.</p>
<h1>Available functions</h1>
<p>Most of the functions are motivated by the theory in the <a href="https://bioconductor.org/books/release/OSCA/"><b>Orchestrating single-cell analysis with Bioconductor</b> book</a>.</p>
<p><b>Identification and filtering of low-quality cells</b> are performed using an outlier-based approach. The <code>PerCellQCMetrics</code> class will compute common QC metrics, the <code>PerCellQCFilters</code> class will identify filtering thresholds from the distribution of such metrics, and the <code>FilterCells</code> class will apply those filters to the count matrix.</p>
<p><b>Log-transformed normalized expression values</b> are computed from the count matrix, using size factors derived from the library size. This is performed using the <code>LogNormCounts</code> class.</p>
<p><b>Variance modelling and selection of highly variable genes</b> is performed on the log-expression values. The <code>ModelGeneVar</code> class will fit a mean-dependent trend to the variances across genes, while the <code>ChooseHVGs</code> class will choose the top set of HVGs based on the residuals from the trend.</p>
<p><b>Principal component analysis</b> is used to compress and denoise the data based on the first few PCs. The <code>RunPCA</code> class will use an approximate PCA algorithm to efficiently compute the top PCs from the HVG-subsetted matrix. Alternatively, the <code>BlockedPCA</code> and <code>MultiBatchPCA</code> classes can be used when dealing with multiple batches.</p>
<p><b>Clustering of cells</b> is performed using the per-cell PC scores. We provide several flavors of graph-based clustering from a shared-nearest neighbor graph, using community detection algorithms such as multi-level (<code>ClusterSnnGraphMultiLevel</code>), Leiden (<code>ClusterSnnGraphLeiden</code>) or Walktrap clustering (<code>ClusterSnnGraphWalktrap</code>). Developers can also easily apply other algorithms, e.g., <a href="https://github.com/LTLA/CppKmeans">k-means</a>.</p>
<p><b>Per-cluster marker detection</b> is performed based on pairwise comparisons between clusters. The <code>ScoreMarkers</code> class will aggregate the set of pairwise comparisons into a single suite of summary statistics for each cluster. Users can then rank by a statistic of interest to obtain a marker listing for each cluster.</p>
<p>The output of PCA is also directly compatible with <a href="https://github.com/LTLA/umappp">UMAP</a> and <a href="https://github.com/LTLA/qdtsne">t-SNE</a> C++ implementations. Readers are referred to the documentation for those libraries for more details.</p>
<h1>Example analysis</h1>
<p>Compile the <a href="https://github.com/LTLA/libscran/blob/master/gallery/minimal.cpp"><code>minimal.cpp</code></a> example by running the following commands at the root of the <b>libscran</b> directory:</p>
<div class="fragment"><div class="line">cmake -S . -B example -DBUILD_TESTING=OFF -DBUILD_GALLERY=ON</div>
<div class="line">cmake --build example --target minimal</div>
</div><!-- fragment --><p>Download and decompress a Matrix Market file containing a scRNA-seq count matrix:</p>
<div class="fragment"><div class="line">mkdir example/data</div>
<div class="line">wget https://cf.10xgenomics.com/samples/cell-exp/2.1.0/pbmc4k/pbmc4k_filtered_gene_bc_matrices.tar.gz -P example/data</div>
<div class="line">tar -xvf example/data/pbmc4k_filtered_gene_bc_matrices.tar.gz --directory example/data</div>
</div><!-- fragment --><p>Run the minimal pipeline:</p>
<div class="fragment"><div class="line">time example/gallery/minimal example/data/filtered_gene_bc_matrices/GRCh38/matrix.mtx</div>
<div class="line"> </div>
<div class="line">## Detected 11 clusters in &#39;example/data/filtered_gene_bc_matrices/GRCh38/matrix.mtx&#39;</div>
<div class="line">## Sizes are 937, 534, 1018, 37, 135, 384, 537, 225, 190, 123, 191</div>
<div class="line">##</div>
<div class="line">## real 0m2.340s</div>
<div class="line">## user 0m9.613s</div>
<div class="line">## sys  0m0.104s</div>
</div><!-- fragment --><h1>Building projects</h1>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  libscran</div>
<div class="line">  GIT_REPOSITORY https://github.com/LTLA/libscran</div>
<div class="line">  GIT_TAG master # or any version of interest </div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(libscran)</div>
</div><!-- fragment --><p>Then you can link to <b>libscran</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe libscran)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE libscran)</div>
</div><!-- fragment --><p>Developers are responsible for linking to the <a href="https://igraph.org"><b>igraph</b></a> C library themselves, either with <code>find_package()</code> or <code>FetchContent</code>. We expect <b>igraph</b> versions from the 0.10 series - see <a href="tests/CMakeLists.txt"><code>tests/CMakeLists.txt</code></a> for the specific version being tested. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
