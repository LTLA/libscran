<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::LogNormCounts Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1LogNormCounts-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::LogNormCounts Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Compute log-normalized expression values.  
 <a href="classscran_1_1LogNormCounts.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LogNormCounts_8hpp_source.html">LogNormCounts.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1LogNormCounts_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee1bffa7e408c11cb003d3bef341af09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#aee1bffa7e408c11cb003d3bef341af09">set_pseudo_count</a> (double p=<a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a4bd0c603b56d3194fc3dc26b310152c9">Defaults::pseudo_count</a>)</td></tr>
<tr class="separator:aee1bffa7e408c11cb003d3bef341af09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065e76faa8ff3e4939ab586673d69ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a065e76faa8ff3e4939ab586673d69ce2">set_sparse_addition</a> (bool a=<a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a96f69b9c59677755aec1d9c3278837fb">Defaults::sparse_addition</a>)</td></tr>
<tr class="separator:a065e76faa8ff3e4939ab586673d69ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ed316546081423d2c920aac8e657a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a17ed316546081423d2c920aac8e657a3">set_center</a> (bool c=<a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#aeb75e212cc28f620391082fc735e7341">Defaults::center</a>)</td></tr>
<tr class="separator:a17ed316546081423d2c920aac8e657a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c8c824927e9404598628d479338544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a37c8c824927e9404598628d479338544">set_block_mode</a> (<a class="el" href="classscran_1_1CenterSizeFactors.html#a511d8d0b9259cd5e3595edb8b8573189">CenterSizeFactors::BlockMode</a> b=<a class="el" href="structscran_1_1CenterSizeFactors_1_1Defaults.html#a1b72abdcaa1fcd1bc846418e0480c2b6">CenterSizeFactors::Defaults::block_mode</a>)</td></tr>
<tr class="separator:a37c8c824927e9404598628d479338544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f72920b0712ca25dab1577a4558a2ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a4f72920b0712ca25dab1577a4558a2ed">set_handle_zeros</a> (bool z=<a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a0b620ea5b5046b58c470297d621647dd">Defaults::handle_zeros</a>)</td></tr>
<tr class="separator:a4f72920b0712ca25dab1577a4558a2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dca9e53795b77524e79bd3aaa8b0d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a61dca9e53795b77524e79bd3aaa8b0d0">set_num_threads</a> (int n=<a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a18d8cbec5037430b2ac7e5a76e6b6d97">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a61dca9e53795b77524e79bd3aaa8b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac1cf3781421591bb1337d12b9ae9eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#adac1cf3781421591bb1337d12b9ae9eb">set_choose_pseudo_count</a> (bool c=<a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a53c44f0ab479e87a88dd43ad850f7690">Defaults::choose_pseudo_count</a>)</td></tr>
<tr class="separator:adac1cf3781421591bb1337d12b9ae9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946c72f7a929b4f4dd11130111ced1a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ChoosePseudoCount.html">ChoosePseudoCount</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a946c72f7a929b4f4dd11130111ced1a8">configure_choose_pseudo_count</a> ()</td></tr>
<tr class="separator:a946c72f7a929b4f4dd11130111ced1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49fea6cb86c25b647606ec7518d8ba6"><td class="memTemplParams" colspan="2">template&lt;class MAT , class V &gt; </td></tr>
<tr class="memitem:ae49fea6cb86c25b647606ec7518d8ba6"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#ae49fea6cb86c25b647606ec7518d8ba6">run</a> (std::shared_ptr&lt; MAT &gt; mat, V size_factors) const</td></tr>
<tr class="separator:ae49fea6cb86c25b647606ec7518d8ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49bf5dbc45a7eced8f37b7ba41b6601e"><td class="memTemplParams" colspan="2">template&lt;class MAT , class V , typename B &gt; </td></tr>
<tr class="memitem:a49bf5dbc45a7eced8f37b7ba41b6601e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a49bf5dbc45a7eced8f37b7ba41b6601e">run_blocked</a> (std::shared_ptr&lt; MAT &gt; mat, V size_factors, const B *block) const</td></tr>
<tr class="separator:a49bf5dbc45a7eced8f37b7ba41b6601e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a428d50cecf39832474c41ba1485809"><td class="memTemplParams" colspan="2">template&lt;class MAT &gt; </td></tr>
<tr class="memitem:a3a428d50cecf39832474c41ba1485809"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a3a428d50cecf39832474c41ba1485809">run</a> (std::shared_ptr&lt; MAT &gt; mat) const</td></tr>
<tr class="separator:a3a428d50cecf39832474c41ba1485809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199ee3089c3bd505e0f56694a9d14094"><td class="memTemplParams" colspan="2">template&lt;class MAT , typename B &gt; </td></tr>
<tr class="memitem:a199ee3089c3bd505e0f56694a9d14094"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a199ee3089c3bd505e0f56694a9d14094">run_blocked</a> (std::shared_ptr&lt; MAT &gt; mat, const B *block) const</td></tr>
<tr class="separator:a199ee3089c3bd505e0f56694a9d14094"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compute log-normalized expression values. </p>
<p>Given a count matrix and a set of size factors, compute log-transformed normalized expression values. Each cell's counts are divided by the cell's size factor, to account for differences in capture efficiency and sequencing depth across cells. The normalized values are then log-transformed so that downstream analyses focus on the relative rather than absolute differences in expression; this process also provides some measure of variance stabilization. These operations are done in a delayed manner using the <code>DelayedIsometricOp</code> class from the <b>tatami</b> library. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aee1bffa7e408c11cb003d3bef341af09" name="aee1bffa7e408c11cb003d3bef341af09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1bffa7e408c11cb003d3bef341af09">&#9670;&#160;</a></span>set_pseudo_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp; scran::LogNormCounts::set_pseudo_count </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em> = <code><a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a4bd0c603b56d3194fc3dc26b310152c9">Defaults::pseudo_count</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the pseudo-count to add to the normalized expression values prior to the log-transformation. Larger pseudo-counts will shrink the log-expression values towards zero such that the dataset variance is driven more by high-abundance genes; this is occasionally useful to mitigate biases introduced by log-expression at low counts. See also <code><a class="el" href="classscran_1_1LogNormCounts.html#adac1cf3781421591bb1337d12b9ae9eb">set_choose_pseudo_count()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pseudo-count, should be a positive number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<a id="a065e76faa8ff3e4939ab586673d69ce2" name="a065e76faa8ff3e4939ab586673d69ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065e76faa8ff3e4939ab586673d69ce2">&#9670;&#160;</a></span>set_sparse_addition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp; scran::LogNormCounts::set_sparse_addition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a96f69b9c59677755aec1d9c3278837fb">Defaults::sparse_addition</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Naive addition of a non-unity pseudo-count will break sparsity. This can be avoided by instead dividing the normalized expression values by the pseudo-count and then applying the usual <code>log1p</code> transformation. However, the resulting values can not be interpreted on the scale of log-counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Whether to use an effective pseudo-count that avoids breaking sparsity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<a id="a17ed316546081423d2c920aac8e657a3" name="a17ed316546081423d2c920aac8e657a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ed316546081423d2c920aac8e657a3">&#9670;&#160;</a></span>set_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp; scran::LogNormCounts::set_center </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#aeb75e212cc28f620391082fc735e7341">Defaults::center</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify whether to center the size factors in <code><a class="el" href="classscran_1_1LogNormCounts.html#ae49fea6cb86c25b647606ec7518d8ba6">run()</a></code>. If <code>true</code>, we center the size factors across cells so that their average is equal to 1; this ensures that the normalized values can still be interpreted on the same scale as the input counts.</p>
<p>If <code>false</code>, no further centering is performed. This is more efficient when size factors are already centered; it may also be useful for re-using this class to compute other normalized values like log-CPMs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to center the size factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<a id="a37c8c824927e9404598628d479338544" name="a37c8c824927e9404598628d479338544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c8c824927e9404598628d479338544">&#9670;&#160;</a></span>set_block_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp; scran::LogNormCounts::set_block_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1CenterSizeFactors.html#a511d8d0b9259cd5e3595edb8b8573189">CenterSizeFactors::BlockMode</a>&#160;</td>
          <td class="paramname"><em>b</em> = <code><a class="el" href="structscran_1_1CenterSizeFactors_1_1Defaults.html#a1b72abdcaa1fcd1bc846418e0480c2b6">CenterSizeFactors::Defaults::block_mode</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Blocking mode, see <code><a class="el" href="classscran_1_1CenterSizeFactors.html#ac8edc812cc10eb1439d21c7d78570650">CenterSizeFactors::set_block_mode()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<a id="a4f72920b0712ca25dab1577a4558a2ed" name="a4f72920b0712ca25dab1577a4558a2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f72920b0712ca25dab1577a4558a2ed">&#9670;&#160;</a></span>set_handle_zeros()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp; scran::LogNormCounts::set_handle_zeros </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>z</em> = <code><a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a0b620ea5b5046b58c470297d621647dd">Defaults::handle_zeros</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify whether to handle zero size factors. If false, size factors of zero will raise an error; otherwise, they will be automatically set to the smallest non-zero size factor after centering (or 1, if all size factors are zero). Setting this to <code>true</code> ensures that any all-zero cells are represented by all-zero columns in the normalized matrix, which is a reasonable outcome if those cells cannot be filtered out during upstream quality control. Note that the centering process ignores zeros, see <code><a class="el" href="classscran_1_1CenterSizeFactors.html#aef603859bb04b43b408c6a67418c69d9">CenterSizeFactors::set_ignore_zeros()</a></code> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>Whether to replace zero size factors with the smallest non-zero size factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<a id="a61dca9e53795b77524e79bd3aaa8b0d0" name="a61dca9e53795b77524e79bd3aaa8b0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61dca9e53795b77524e79bd3aaa8b0d0">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp; scran::LogNormCounts::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a18d8cbec5037430b2ac7e5a76e6b6d97">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object.</dd></dl>
<p>Parallelization is only performed to compute size factors, so this method only has an effect if <code>size_factors</code> are not passed to <code><a class="el" href="classscran_1_1LogNormCounts.html#ae49fea6cb86c25b647606ec7518d8ba6">run()</a></code>. </p>

</div>
</div>
<a id="adac1cf3781421591bb1337d12b9ae9eb" name="adac1cf3781421591bb1337d12b9ae9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac1cf3781421591bb1337d12b9ae9eb">&#9670;&#160;</a></span>set_choose_pseudo_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp; scran::LogNormCounts::set_choose_pseudo_count </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code><a class="el" href="structscran_1_1LogNormCounts_1_1Defaults.html#a53c44f0ab479e87a88dd43ad850f7690">Defaults::choose_pseudo_count</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to automatically choose an appropriate pseudo-count based on the (centered) size factors. See <code><a class="el" href="classscran_1_1ChoosePseudoCount.html" title="Choose a pseudo-count for log-transformation.">ChoosePseudoCount</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<a id="a946c72f7a929b4f4dd11130111ced1a8" name="a946c72f7a929b4f4dd11130111ced1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946c72f7a929b4f4dd11130111ced1a8">&#9670;&#160;</a></span>configure_choose_pseudo_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ChoosePseudoCount.html">ChoosePseudoCount</a> &amp; scran::LogNormCounts::configure_choose_pseudo_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Reference to a <code><a class="el" href="classscran_1_1ChoosePseudoCount.html" title="Choose a pseudo-count for log-transformation.">ChoosePseudoCount</a></code> object, for non-default parameter specification when <code><a class="el" href="classscran_1_1LogNormCounts.html#adac1cf3781421591bb1337d12b9ae9eb">set_choose_pseudo_count()</a></code> is set to <code>true</code>. </dd></dl>

</div>
</div>
<a id="ae49fea6cb86c25b647606ec7518d8ba6" name="ae49fea6cb86c25b647606ec7518d8ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49fea6cb86c25b647606ec7518d8ba6">&#9670;&#160;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; scran::LogNormCounts::run </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>size_factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute log-normalized expression values from an input matrix. To avoid copying the data, this is done in a delayed manner using the <code>DelayedIsometricOp</code> class from the <b>tatami</b> package.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td>A <b>tatami</b> matrix class, most typically a <code>tatami::NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">V</td><td>A vector class supporting <code>size()</code>, random access via <code>[</code>, <code>begin()</code>, <code>end()</code> and <code>data()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to an input count matrix, with features in the rows and cells in the columns. </td></tr>
    <tr><td class="paramname">size_factors</td><td>A vector of positive size factors, of length equal to the number of columns in <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a matrix of log-transformed and normalized values. </dd></dl>

</div>
</div>
<a id="a49bf5dbc45a7eced8f37b7ba41b6601e" name="a49bf5dbc45a7eced8f37b7ba41b6601e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49bf5dbc45a7eced8f37b7ba41b6601e">&#9670;&#160;</a></span>run_blocked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT , class V , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; scran::LogNormCounts::run_blocked </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute log-normalized expression values from an input matrix with blocking. Specifically, centering of size factors is performed within each block. This allows users to easily mimic normalization of different blocks of cells (e.g., from different samples) in the same matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td>A <b>tatami</b> matrix class, most typically a <code>tatami::NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">V</td><td>A vector class supporting <code>size()</code>, random access via <code>[</code>, <code>begin()</code>, <code>end()</code> and <code>data()</code>. </td></tr>
    <tr><td class="paramname">B</td><td>An integer type, to hold the block IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Pointer to an input count matrix, with features in the rows and cells in the columns. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size_factors</td><td>A vector of positive size factors, of length equal to the number of columns in <code>mat</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of block identifiers. If provided, the array should be of length equal to the number of columns in <code>mat</code>. Values should be integer IDs in <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[0, N)$" src="form_0.png"/></picture> where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> is the number of blocks. This can also be a <code>NULL</code>, in which case all cells are assumed to belong to the same block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a matrix of log-transformed and normalized values. </dd></dl>

</div>
</div>
<a id="a3a428d50cecf39832474c41ba1485809" name="a3a428d50cecf39832474c41ba1485809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a428d50cecf39832474c41ba1485809">&#9670;&#160;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; scran::LogNormCounts::run </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute log-normalized expression values from an input matrix. Size factors are defined as the sum of the total counts for each cell.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td>A <b>tatami</b> matrix class, most typically a <code>tatami::NumericMatrix</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to an input count matrix, with features in the rows and cells in the columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a matrix of log-transformed and normalized values. </dd></dl>

</div>
</div>
<a id="a199ee3089c3bd505e0f56694a9d14094" name="a199ee3089c3bd505e0f56694a9d14094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199ee3089c3bd505e0f56694a9d14094">&#9670;&#160;</a></span>run_blocked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; MAT &gt; scran::LogNormCounts::run_blocked </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute log-normalized expression values from an input matrix with blocking, see <code><a class="el" href="classscran_1_1LogNormCounts.html#a49bf5dbc45a7eced8f37b7ba41b6601e">run_blocked()</a></code> for details. Size factors are defined as the sum of the total counts for each cell.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td>A <b>tatami</b> matrix class, most typically a <code>tatami::NumericMatrix</code>. </td></tr>
    <tr><td class="paramname">B</td><td>An integer type, to hold the block IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Pointer to an input count matrix, with features in the rows and cells in the columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of block identifiers, see <code><a class="el" href="classscran_1_1LogNormCounts.html#a49bf5dbc45a7eced8f37b7ba41b6601e">run_blocked()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a matrix of log-transformed and normalized values. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/normalization/<a class="el" href="LogNormCounts_8hpp_source.html">LogNormCounts.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
