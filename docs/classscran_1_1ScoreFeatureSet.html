<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::ScoreFeatureSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1ScoreFeatureSet-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::ScoreFeatureSet Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Compute per-cell scores for a given feature set.  
 <a href="classscran_1_1ScoreFeatureSet.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ScoreFeatureSet_8hpp_source.html">ScoreFeatureSet.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameters.  <a href="structscran_1_1ScoreFeatureSet_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Feature set scoring results.  <a href="structscran_1_1ScoreFeatureSet_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3dcf5ea98c74cd2d9fad088550fef1e3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreFeatureSet.html#a3dcf5ea98c74cd2d9fad088550fef1e3">BlockPolicy</a> { <b>AVERAGE</b>
, <b>MAXIMUM</b>
 }</td></tr>
<tr class="separator:a3dcf5ea98c74cd2d9fad088550fef1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb7f3276a5543508236d3fed93198338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreFeatureSet.html#aeb7f3276a5543508236d3fed93198338">set_block_policy</a> (<a class="el" href="classscran_1_1ScoreFeatureSet.html#a3dcf5ea98c74cd2d9fad088550fef1e3">BlockPolicy</a> b=<a class="el" href="structscran_1_1ScoreFeatureSet_1_1Defaults.html#a10558ed29bee433ceda832051b13f000">Defaults::block_policy</a>)</td></tr>
<tr class="separator:aeb7f3276a5543508236d3fed93198338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2999a41031be48d138dbf5cedd2c36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreFeatureSet.html#a5c2999a41031be48d138dbf5cedd2c36">set_num_threads</a> (int n=<a class="el" href="structscran_1_1ScoreFeatureSet_1_1Defaults.html#a518aa9ca768c8b5cbafa0f0820533912">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a5c2999a41031be48d138dbf5cedd2c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6892c7b954ddd7ca056b94ae772fc309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreFeatureSet.html#a6892c7b954ddd7ca056b94ae772fc309">set_scale</a> (bool s=<a class="el" href="structscran_1_1ScoreFeatureSet_1_1Defaults.html#ad6b829970b884c66a0e81df6d169caef">Defaults::scale</a>)</td></tr>
<tr class="separator:a6892c7b954ddd7ca056b94ae772fc309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094fa78564a7c646578d92ebdf5a299e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , typename X , typename Block &gt; </td></tr>
<tr class="memitem:a094fa78564a7c646578d92ebdf5a299e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Results.html">Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreFeatureSet.html#a094fa78564a7c646578d92ebdf5a299e">run_blocked</a> (const tatami::Matrix&lt; T, IDX &gt; *mat, const X *features, const Block *block) const</td></tr>
<tr class="separator:a094fa78564a7c646578d92ebdf5a299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59f4fa36aed91e44dc3bf03ebd678a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , typename X &gt; </td></tr>
<tr class="memitem:ab59f4fa36aed91e44dc3bf03ebd678a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Results.html">Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1ScoreFeatureSet.html#ab59f4fa36aed91e44dc3bf03ebd678a8">run</a> (const tatami::Matrix&lt; T, IDX &gt; *mat, const X *features) const</td></tr>
<tr class="separator:ab59f4fa36aed91e44dc3bf03ebd678a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compute per-cell scores for a given feature set. </p>
<p>Per-cell scores are defined as the column means of the rank-1 approximation of the input matrix for the subset of features in the set. The central idea here is that the primary activity of the feature set can be quantified by the largest component of variance amongst its features. (If this was not the case, one could argue that this feature set is not well-suited to capture the biology attributed to it.) In effect, the rotation vector define weights for all features in the set, focusing on genes that contribute to the primary activity. This is based on the <a href="https://github.com/JasonHackney/GSDecon"><b>GSDecon</b></a> package from Jason Hackney.</p>
<p>For multi-block analyses, we extend this approach by computing the rotation vector separately within each block. We then aggregate the rotation vector across blocks - either by computing the weighted average where the weights are defined as the proportion of variance explained by the first PC in each block; or by taking the rotation vector with the largest proportion of variance explained. Each cell is projected onto this rotation vector, and the feature set score for each cell is then defined from the ensuing rank-1 approximation. This approach avoids comparing cells between blocks and favors blocks where the feature set has greater (relative) activity. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3dcf5ea98c74cd2d9fad088550fef1e3" name="a3dcf5ea98c74cd2d9fad088550fef1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcf5ea98c74cd2d9fad088550fef1e3">&#9670;&#160;</a></span>BlockPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classscran_1_1ScoreFeatureSet.html#a3dcf5ea98c74cd2d9fad088550fef1e3">scran::ScoreFeatureSet::BlockPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Policy to use to combine rotation vectors across blocks.</p>
<ul>
<li><code>AVERAGE</code> will average rotation vectors, using the proportion of variance explained by the first PC within each block as the weight.</li>
<li><code>MAXIMUM</code> will take the rotation vector from the block with the largest proportion of variance explained by the first PC. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb7f3276a5543508236d3fed93198338" name="aeb7f3276a5543508236d3fed93198338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7f3276a5543508236d3fed93198338">&#9670;&#160;</a></span>set_block_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a> &amp; scran::ScoreFeatureSet::set_block_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1ScoreFeatureSet.html#a3dcf5ea98c74cd2d9fad088550fef1e3">BlockPolicy</a>&#160;</td>
          <td class="paramname"><em>b</em> = <code><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Defaults.html#a10558ed29bee433ceda832051b13f000">Defaults::block_policy</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Policy to use when combining rotation vectors from multiple blocks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreFeatureSet.html" title="Compute per-cell scores for a given feature set.">ScoreFeatureSet</a></code> instance. </dd></dl>

</div>
</div>
<a id="a5c2999a41031be48d138dbf5cedd2c36" name="a5c2999a41031be48d138dbf5cedd2c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2999a41031be48d138dbf5cedd2c36">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a> &amp; scran::ScoreFeatureSet::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Defaults.html#a518aa9ca768c8b5cbafa0f0820533912">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreFeatureSet.html" title="Compute per-cell scores for a given feature set.">ScoreFeatureSet</a></code> object. </dd></dl>

</div>
</div>
<a id="a6892c7b954ddd7ca056b94ae772fc309" name="a6892c7b954ddd7ca056b94ae772fc309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6892c7b954ddd7ca056b94ae772fc309">&#9670;&#160;</a></span>set_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1ScoreFeatureSet.html">ScoreFeatureSet</a> &amp; scran::ScoreFeatureSet::set_scale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Defaults.html#ad6b829970b884c66a0e81df6d169caef">Defaults::scale</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Whether to scale each block so that its features have unit variance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1ScoreFeatureSet.html" title="Compute per-cell scores for a given feature set.">ScoreFeatureSet</a></code> object. </dd></dl>

</div>
</div>
<a id="a094fa78564a7c646578d92ebdf5a299e" name="a094fa78564a7c646578d92ebdf5a299e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094fa78564a7c646578d92ebdf5a299e">&#9670;&#160;</a></span>run_blocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , typename X , typename Block &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Results.html">Results</a> scran::ScoreFeatureSet::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X *&#160;</td>
          <td class="paramname"><em>features</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type for the data. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">X</td><td>Integer type for the feature filter. </td></tr>
    <tr><td class="paramname">Block</td><td>Integer type for the block assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to the input matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">features</td><td>Pointer to an array of length equal to the number of rows in <code>mat</code>, specifying the features in the set of interest. Non-zero values indicate that the corresponding row is part of the feature set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>mat</code>. This should contain the blocking factor as 0-based block assignments (i.e., for <code>n</code> blocks, block identities should run from 0 to <code>n-1</code> with at least one entry for each block.) If this is <code>NULL</code>, all cells are assumed to belong to the same block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Results.html" title="Feature set scoring results.">Results</a></code> object containing the per-cell scores and per-feature weights. </dd></dl>

</div>
</div>
<a id="ab59f4fa36aed91e44dc3bf03ebd678a8" name="ab59f4fa36aed91e44dc3bf03ebd678a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59f4fa36aed91e44dc3bf03ebd678a8">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Results.html">Results</a> scran::ScoreFeatureSet::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X *&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An overload of <code><a class="el" href="classscran_1_1ScoreFeatureSet.html#ab59f4fa36aed91e44dc3bf03ebd678a8">run()</a></code> where all cells are assumed to belong to the same block.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type for the data. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">X</td><td>Integer type for the feature filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to the input matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">features</td><td>Pointer to an array of length equal to the number of rows in <code>mat</code>, specifying the features in the set of interest. Non-zero values indicate that the corresponding row is part of the feature set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1ScoreFeatureSet_1_1Results.html" title="Feature set scoring results.">Results</a></code> object containing the per-cell scores and per-feature weights. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/aggregation/<a class="el" href="ScoreFeatureSet_8hpp_source.html">ScoreFeatureSet.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
