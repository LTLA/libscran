<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::BuildSnnGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1BuildSnnGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::BuildSnnGraph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Build a shared nearest-neighbor graph with cells as nodes.  
 <a href="classscran_1_1BuildSnnGraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BuildSnnGraph_8hpp_source.html">BuildSnnGraph.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1BuildSnnGraph_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html" title="Results of SNN graph construction.">Results</a> of SNN graph construction.  <a href="structscran_1_1BuildSnnGraph_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a906e3225f1422bbb7eb1491d2e42cfe0" id="r_a906e3225f1422bbb7eb1491d2e42cfe0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#a906e3225f1422bbb7eb1491d2e42cfe0">Scheme</a> { <b>RANKED</b>
, <b>NUMBER</b>
, <b>JACCARD</b>
 }</td></tr>
<tr class="separator:a906e3225f1422bbb7eb1491d2e42cfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac4618f549883ad2d1750b15e2832d0eb" id="r_ac4618f549883ad2d1750b15e2832d0eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#ac4618f549883ad2d1750b15e2832d0eb">set_neighbors</a> (int k=<a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#acd569e0cecda9c58eb4a2b712be24727">Defaults::neighbors</a>)</td></tr>
<tr class="separator:ac4618f549883ad2d1750b15e2832d0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78749ca82b834dfdf8da71013bdf01f9" id="r_a78749ca82b834dfdf8da71013bdf01f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#a78749ca82b834dfdf8da71013bdf01f9">set_approximate</a> (bool a=<a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#a8b2564988a29d5000391dd26f0e92faa">Defaults::approximate</a>)</td></tr>
<tr class="separator:a78749ca82b834dfdf8da71013bdf01f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37b047b6a66c3bcf3a33346c359e2b6" id="r_af37b047b6a66c3bcf3a33346c359e2b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#af37b047b6a66c3bcf3a33346c359e2b6">set_weighting_scheme</a> (<a class="el" href="classscran_1_1BuildSnnGraph.html#a906e3225f1422bbb7eb1491d2e42cfe0">Scheme</a> w=<a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#a9798eabf4dabc4dc13b8ce582be069ae">Defaults::weighting_scheme</a>)</td></tr>
<tr class="separator:af37b047b6a66c3bcf3a33346c359e2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab102b0aee1a8f24348cce61e2818080" id="r_aab102b0aee1a8f24348cce61e2818080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#aab102b0aee1a8f24348cce61e2818080">set_num_threads</a> (int n=<a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#afb871756c085c850b48d3ca2a46ddeae">Defaults::num_threads</a>)</td></tr>
<tr class="separator:aab102b0aee1a8f24348cce61e2818080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae491f72749e54804144bff07734ca511" id="r_ae491f72749e54804144bff07734ca511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#ae491f72749e54804144bff07734ca511">run</a> (size_t ndims, size_t ncells, const double *mat) const</td></tr>
<tr class="separator:ae491f72749e54804144bff07734ca511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec5918fd3b2a4537cc40ef86a4b705a" id="r_a4ec5918fd3b2a4537cc40ef86a4b705a"><td class="memTemplParams" colspan="2">template&lt;class Algorithm &gt; </td></tr>
<tr class="memitem:a4ec5918fd3b2a4537cc40ef86a4b705a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#a4ec5918fd3b2a4537cc40ef86a4b705a">run</a> (const Algorithm *search) const</td></tr>
<tr class="separator:a4ec5918fd3b2a4537cc40ef86a4b705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2e241c4730af640653f928e9199783" id="r_a2b2e241c4730af640653f928e9199783"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Distance_ &gt; </td></tr>
<tr class="memitem:a2b2e241c4730af640653f928e9199783"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#a2b2e241c4730af640653f928e9199783">run</a> (const knncolle::NeighborList&lt; Index_, Distance_ &gt; &amp;neighbors) const</td></tr>
<tr class="separator:a2b2e241c4730af640653f928e9199783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee616523bdda1c63b1d24af1494e5477" id="r_aee616523bdda1c63b1d24af1494e5477"><td class="memTemplParams" colspan="2">template&lt;class Indices_ &gt; </td></tr>
<tr class="memitem:aee616523bdda1c63b1d24af1494e5477"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1BuildSnnGraph.html#aee616523bdda1c63b1d24af1494e5477">run</a> (const std::vector&lt; Indices_ &gt; &amp;indices) const</td></tr>
<tr class="separator:aee616523bdda1c63b1d24af1494e5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Build a shared nearest-neighbor graph with cells as nodes. </p>
<p>In a shared nearest neighbor graph, pairs of cells are connected to each other by an edge with weight determined from their shared nearest neighbors. If two cells are close together but have distinct sets of neighbors, the corresponding edge is downweighted as the two cells are unlikely to be part of the same neighborhood. In this manner, highly weighted edges will form within highly interconnected neighborhoods where many cells share the same neighbors. This provides a more sophisticated definition of similarity between cells compared to a simpler (unweighted) nearest neighbor graph that just focuses on immediate proximity.</p>
<p>A key parameter in the construction of the graph is the number of nearest neighbors $k$ to consider. Larger values increase the connectivity of the graph and reduce the granularity of any subsequent community detection steps (see <code>scran::ClusterSnnGraph</code>) at the cost of speed. The nearest neighbor search can be performed using either vantage point trees (exact) or with the Annoy algorithm (approximate) - see the <a href="https://github.com/LTLA/knncolle"><b>knncolle</b></a> library for details.</p>
<p>For the edges, a variety of weighting schemes are possible:</p>
<ul>
<li><code>RANKED</code> defines the weight between two nodes as $k - r/2$ where $r$ is the smallest sum of ranks for any shared neighboring node (Xu and Su, 2015). For the purposes of this ranking, each node has a rank of zero in its own nearest-neighbor set. More shared neighbors, or shared neighbors that are close to both observations, will generally yield larger weights.</li>
<li><code>NUMBER</code> defines the weight between two nodes as the number of shared nearest neighbors between them. The weight can range from zero to $k + 1$, as the node itself is included in its own nearest-neighbor set. This is a simpler scheme that is also slightly faster but does not account for the ranking of neighbors within each set.</li>
<li><code>JACCARD</code> defines the weight between two nodes as the Jaccard index of their neighbor sets. This weight can range from zero to 1, and is a monotonic transformation of the weight used by <code>NUMBER</code>.</li>
</ul>
<p>See the <code>ClusterSNNGraph</code> class to perform community detection on the graph returned by <code>run()</code>.</p>
<dl class="section see"><dt>See also</dt><dd>Xu C and Su Z (2015). Identification of cell types from single-cell transcriptomes using a novel clustering method. <em>Bioinformatics</em> 31, 1974-80 </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a906e3225f1422bbb7eb1491d2e42cfe0" name="a906e3225f1422bbb7eb1491d2e42cfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906e3225f1422bbb7eb1491d2e42cfe0">&#9670;&#160;</a></span>Scheme</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classscran_1_1BuildSnnGraph.html#a906e3225f1422bbb7eb1491d2e42cfe0">scran::BuildSnnGraph::Scheme</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choices for the edge weighting scheme during graph construction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4618f549883ad2d1750b15e2832d0eb" name="ac4618f549883ad2d1750b15e2832d0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4618f549883ad2d1750b15e2832d0eb">&#9670;&#160;</a></span>set_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp; scran::BuildSnnGraph::set_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#acd569e0cecda9c58eb4a2b712be24727">Defaults::neighbors</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of neighbors to use in the nearest neighbor search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1BuildSnnGraph.html" title="Build a shared nearest-neighbor graph with cells as nodes.">BuildSnnGraph</a></code> object. </dd></dl>

</div>
</div>
<a id="a78749ca82b834dfdf8da71013bdf01f9" name="a78749ca82b834dfdf8da71013bdf01f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78749ca82b834dfdf8da71013bdf01f9">&#9670;&#160;</a></span>set_approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp; scran::BuildSnnGraph::set_approximate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#a8b2564988a29d5000391dd26f0e92faa">Defaults::approximate</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Whether to perform an approximate nearest neighbor search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1BuildSnnGraph.html" title="Build a shared nearest-neighbor graph with cells as nodes.">BuildSnnGraph</a></code> object. </dd></dl>

</div>
</div>
<a id="af37b047b6a66c3bcf3a33346c359e2b6" name="af37b047b6a66c3bcf3a33346c359e2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37b047b6a66c3bcf3a33346c359e2b6">&#9670;&#160;</a></span>set_weighting_scheme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp; scran::BuildSnnGraph::set_weighting_scheme </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classscran_1_1BuildSnnGraph.html#a906e3225f1422bbb7eb1491d2e42cfe0">Scheme</a>&#160;</td>
          <td class="paramname"><em>w</em> = <code><a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#a9798eabf4dabc4dc13b8ce582be069ae">Defaults::weighting_scheme</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>The edge weighting scheme to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1BuildSnnGraph.html" title="Build a shared nearest-neighbor graph with cells as nodes.">BuildSnnGraph</a></code> object. </dd></dl>

</div>
</div>
<a id="aab102b0aee1a8f24348cce61e2818080" name="aab102b0aee1a8f24348cce61e2818080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab102b0aee1a8f24348cce61e2818080">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1BuildSnnGraph.html">BuildSnnGraph</a> &amp; scran::BuildSnnGraph::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1BuildSnnGraph_1_1Defaults.html#afb871756c085c850b48d3ca2a46ddeae">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1BuildSnnGraph.html" title="Build a shared nearest-neighbor graph with cells as nodes.">BuildSnnGraph</a></code> object. </dd></dl>

</div>
</div>
<a id="ae491f72749e54804144bff07734ca511" name="ae491f72749e54804144bff07734ca511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae491f72749e54804144bff07734ca511">&#9670;&#160;</a></span>run() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a> scran::BuildSnnGraph::run </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndims</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramname">mat</td><td>Pointer to an array of expression values or a low-dimensional representation thereof. Rows should be dimensions while columns should be cells. Data should be stored in column-major format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the constructed SNN graph. </dd></dl>

</div>
</div>
<a id="a4ec5918fd3b2a4537cc40ef86a4b705a" name="a4ec5918fd3b2a4537cc40ef86a4b705a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec5918fd3b2a4537cc40ef86a4b705a">&#9670;&#160;</a></span>run() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Algorithm &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a> scran::BuildSnnGraph::run </td>
          <td>(</td>
          <td class="paramtype">const Algorithm *&#160;</td>
          <td class="paramname"><em>search</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Algorithm</td><td>Any instance of a <code>knncolle::Base</code> subclass.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search</td><td>Pointer to a <code>knncolle::Base</code> instance to use for the nearest-neighbor search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the constructed SNN graph. </dd></dl>

</div>
</div>
<a id="a2b2e241c4730af640653f928e9199783" name="a2b2e241c4730af640653f928e9199783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2e241c4730af640653f928e9199783">&#9670;&#160;</a></span>run() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Distance_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a> scran::BuildSnnGraph::run </td>
          <td>(</td>
          <td class="paramtype">const knncolle::NeighborList&lt; Index_, Distance_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neighbors</td><td>Vector of indices and distances of the neighbors for each cell, sorted by increasing distance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the constructed SNN graph.</dd></dl>
<p>Distances are ignored here; this overload is only provided to enable convenient usage with pre-computed neighbors from <b>knncolle</b>. </p>

</div>
</div>
<a id="aee616523bdda1c63b1d24af1494e5477" name="aee616523bdda1c63b1d24af1494e5477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee616523bdda1c63b1d24af1494e5477">&#9670;&#160;</a></span>run() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Indices_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1BuildSnnGraph_1_1Results.html">Results</a> scran::BuildSnnGraph::run </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Indices_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Indices_</td><td>Vector-like class containing integer indices. This should provide the <code>[</code> and <code>size()</code> methods.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Vector of indices of the neighbors for each cell, sorted by increasing distance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges and weights of the constructed SNN graph. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/clustering/<a class="el" href="BuildSnnGraph_8hpp_source.html">BuildSnnGraph.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
