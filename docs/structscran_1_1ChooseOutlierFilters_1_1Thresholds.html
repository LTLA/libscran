<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::ChooseOutlierFilters::Thresholds Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="structscran_1_1ChooseOutlierFilters.html">ChooseOutlierFilters</a></li><li class="navelem"><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html">Thresholds</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structscran_1_1ChooseOutlierFilters_1_1Thresholds-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::ChooseOutlierFilters::Thresholds Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Outlier thresholds for QC filtering.  
 <a href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ChooseOutlierFilters_8hpp_source.html">ChooseOutlierFilters.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9da2ef088b68b5964832639b3fb27a24"><td class="memTemplParams" colspan="2">template&lt;bool overwrite = true, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a9da2ef088b68b5964832639b3fb27a24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#a9da2ef088b68b5964832639b3fb27a24">filter</a> (size_t n, Input *input, Output *output) const</td></tr>
<tr class="separator:a9da2ef088b68b5964832639b3fb27a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69689e977f6dafaa66ceaa089927770"><td class="memTemplParams" colspan="2">template&lt;typename Output  = uint8_t, typename Input &gt; </td></tr>
<tr class="memitem:ad69689e977f6dafaa66ceaa089927770"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#ad69689e977f6dafaa66ceaa089927770">filter</a> (size_t n, const Input *input) const</td></tr>
<tr class="separator:ad69689e977f6dafaa66ceaa089927770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc947e6502a064baa9de27a758b405b6"><td class="memTemplParams" colspan="2">template&lt;bool overwrite = true, typename Block , typename Input , typename Output &gt; </td></tr>
<tr class="memitem:adc947e6502a064baa9de27a758b405b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#adc947e6502a064baa9de27a758b405b6">filter_blocked</a> (size_t n, const Block *block, const Input *input, Output *output) const</td></tr>
<tr class="separator:adc947e6502a064baa9de27a758b405b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417f0719042afd99507410b33197ad93"><td class="memTemplParams" colspan="2">template&lt;typename Output  = uint8_t, typename Block , typename Input &gt; </td></tr>
<tr class="memitem:a417f0719042afd99507410b33197ad93"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#a417f0719042afd99507410b33197ad93">filter_blocked</a> (size_t n, const Block *block, const Input *input) const</td></tr>
<tr class="separator:a417f0719042afd99507410b33197ad93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a847938b5a3a9143f4bb9eabda2ee068d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#a847938b5a3a9143f4bb9eabda2ee068d">lower</a></td></tr>
<tr class="separator:a847938b5a3a9143f4bb9eabda2ee068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98445cd7e1fd152578ed88a191530478"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#a98445cd7e1fd152578ed88a191530478">upper</a></td></tr>
<tr class="separator:a98445cd7e1fd152578ed88a191530478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Outlier thresholds for QC filtering. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9da2ef088b68b5964832639b3fb27a24" name="a9da2ef088b68b5964832639b3fb27a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da2ef088b68b5964832639b3fb27a24">&#9670;&#160;</a></span>filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool overwrite = true, typename Input , typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::ChooseOutlierFilters::Thresholds::filter </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Input *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">overwrite</td><td>Whether to overwrite existing truthy entries in <code>output</code>. </td></tr>
    <tr><td class="paramname">Input</td><td>Numeric type for the values. </td></tr>
    <tr><td class="paramname">Output</td><td>Boolean type for the outlier calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array of length <code>n</code>, containing the values to be filtered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length <code>n</code>, to store the outlier calls. Values are set to <code>true</code> for outliers. If <code>overwrite = true</code>, values are set to <code>false</code> for non-outliers, otherwise the existing entry is preserved.</td></tr>
  </table>
  </dd>
</dl>
<p>Use <code><a class="el" href="structscran_1_1ChooseOutlierFilters_1_1Thresholds.html#adc947e6502a064baa9de27a758b405b6">filter_blocked()</a></code> instead for multi-block datasets. </p>

</div>
</div>
<a id="ad69689e977f6dafaa66ceaa089927770" name="ad69689e977f6dafaa66ceaa089927770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69689e977f6dafaa66ceaa089927770">&#9670;&#160;</a></span>filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = uint8_t, typename Input &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; scran::ChooseOutlierFilters::Thresholds::filter </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Input *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Boolean type for the outlier calls. </td></tr>
    <tr><td class="paramname">Input</td><td>Numeric type for the values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array of length <code>n</code>, containing the values to be filtered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of outlier calls, of length equal to <code>n</code>. </dd></dl>

</div>
</div>
<a id="adc947e6502a064baa9de27a758b405b6" name="adc947e6502a064baa9de27a758b405b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc947e6502a064baa9de27a758b405b6">&#9670;&#160;</a></span>filter_blocked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool overwrite = true, typename Block , typename Input , typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::ChooseOutlierFilters::Thresholds::filter_blocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Input *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">overwrite</td><td>Whether to overwrite existing truthy entries in <code>output</code>. </td></tr>
    <tr><td class="paramname">Block</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Input</td><td>Numeric type for the values. </td></tr>
    <tr><td class="paramname">Output</td><td>Boolean type for the outlier calls.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length <code>n</code>, containing the block assignment for each cell. This may be <code>NULL</code>, in which case all cells are assumed to belong to the same block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array of length <code>n</code>, containing the values to be filtered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length <code>n</code>, to store the outlier calls. Values are set to <code>true</code> for outliers. If <code>overwrite = true</code>, values are set to <code>false</code> for non-outliers, otherwise the existing entry is preserved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a417f0719042afd99507410b33197ad93" name="a417f0719042afd99507410b33197ad93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417f0719042afd99507410b33197ad93">&#9670;&#160;</a></span>filter_blocked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output  = uint8_t, typename Block , typename Input &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output &gt; scran::ChooseOutlierFilters::Thresholds::filter_blocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Input *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output</td><td>Boolean type for the outlier calls. </td></tr>
    <tr><td class="paramname">Block</td><td>Integer type for the block assignments. </td></tr>
    <tr><td class="paramname">Input</td><td>Numeric type for the values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length <code>n</code>, containing the block assignment for each cell. This may be <code>NULL</code>, in which case all cells are assumed to belong to the same block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Pointer to an array of length <code>n</code>, containing the values to be filtered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of low-quality calls, of length equal to the number of cells in <code>metrics</code>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a847938b5a3a9143f4bb9eabda2ee068d" name="a847938b5a3a9143f4bb9eabda2ee068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847938b5a3a9143f4bb9eabda2ee068d">&#9670;&#160;</a></span>lower</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; scran::ChooseOutlierFilters::Thresholds::lower</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vector of lower thresholds, one per batch. Cells where the relevant QC metric is below this threshold are considered to be low quality. If empty, no lower threshold is to be used. </p>

</div>
</div>
<a id="a98445cd7e1fd152578ed88a191530478" name="a98445cd7e1fd152578ed88a191530478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98445cd7e1fd152578ed88a191530478">&#9670;&#160;</a></span>upper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; scran::ChooseOutlierFilters::Thresholds::upper</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vector of upper thresholds, one per batch. Cells where the relevant QC metric is above this threshold are considered to be low quality. If empty, no upper threshold is to be used. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>scran/quality_control/<a class="el" href="ChooseOutlierFilters_8hpp_source.html">ChooseOutlierFilters.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
