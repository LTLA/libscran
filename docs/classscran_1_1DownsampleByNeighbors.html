<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::DownsampleByNeighbors Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1DownsampleByNeighbors-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::DownsampleByNeighbors Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Downsample a dataset based on its neighbors.  
 <a href="classscran_1_1DownsampleByNeighbors.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DownsampleByNeighbors_8hpp_source.html">DownsampleByNeighbors.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aba8c99956dc466841c902a938cd01d31" id="r_aba8c99956dc466841c902a938cd01d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1DownsampleByNeighbors.html#aba8c99956dc466841c902a938cd01d31">set_num_neighbors</a> (int k=<a class="el" href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html#ae9d8590d702e5ddcb55a74b14bf65cad">Defaults::num_neighbors</a>)</td></tr>
<tr class="separator:aba8c99956dc466841c902a938cd01d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6891a8dc59fe89d40cf4915da4a15fd1" id="r_a6891a8dc59fe89d40cf4915da4a15fd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a6891a8dc59fe89d40cf4915da4a15fd1">set_num_threads</a> (int n=<a class="el" href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html#a29317eaf1d45bde61a807c8b97a0854d">Defaults::num_threads</a>)</td></tr>
<tr class="separator:a6891a8dc59fe89d40cf4915da4a15fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5993d8df83b1a4dd8e0dc1ff42ee45" id="r_a6b5993d8df83b1a4dd8e0dc1ff42ee45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a6b5993d8df83b1a4dd8e0dc1ff42ee45">set_approximate</a> (int a=<a class="el" href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html#a217dc2cf9a3fb84e137360a078b0ea49">Defaults::approximate</a>)</td></tr>
<tr class="separator:a6b5993d8df83b1a4dd8e0dc1ff42ee45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fefac1ba6a166d97e525ba63593fddd" id="r_a3fefac1ba6a166d97e525ba63593fddd"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Float &gt; </td></tr>
<tr class="memitem:a3fefac1ba6a166d97e525ba63593fddd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a3fefac1ba6a166d97e525ba63593fddd">run</a> (const std::vector&lt; std::vector&lt; std::pair&lt; Index, Float &gt; &gt; &gt; &amp;neighbors, Index *assigned) const</td></tr>
<tr class="separator:a3fefac1ba6a166d97e525ba63593fddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b88cc9e50826fe0a399c3a9f15e3361" id="r_a3b88cc9e50826fe0a399c3a9f15e3361"><td class="memTemplParams" colspan="2">template&lt;typename Index  = int, typename Float &gt; </td></tr>
<tr class="memitem:a3b88cc9e50826fe0a399c3a9f15e3361"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a3b88cc9e50826fe0a399c3a9f15e3361">run</a> (int ndim, size_t nobs, const Float *data, Index *assigned) const</td></tr>
<tr class="separator:a3b88cc9e50826fe0a399c3a9f15e3361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582b257a8a333ffc4ae94ae3288055f2" id="r_a582b257a8a333ffc4ae94ae3288055f2"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Float &gt; </td></tr>
<tr class="memitem:a582b257a8a333ffc4ae94ae3288055f2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a582b257a8a333ffc4ae94ae3288055f2">run</a> (const knncolle::Base&lt; Index, Float &gt; *index, Index *assigned) const</td></tr>
<tr class="separator:a582b257a8a333ffc4ae94ae3288055f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Downsample a dataset based on its neighbors. </p>
<p>This function generates a deterministic downsampling of a dataset based on nearest neighbors. To do so, we identify the <code>k</code>-nearest neighbors of each cell and use that to define its local neighborhood. We find the cell that does not belong in the local neighborhood of any previously retained cell, and has the fewest neighbors in any of the local neighborhoods of previously retained cells; ties are broken using the smallest distance to the cell's <code>k</code>-th neighbor (i.e., the densest region of space). This cell is retained in the downsampled subset and we repeat this process until all cells have been processed.</p>
<p>Each retained cell serves as a representative for up to <code>k</code> of its nearest neighboring cells. This approach ensures that the downsampled points are well-distributed across the dataset. Low-frequency subpopulations will always have at least a few representatives if they are sufficiently distant from other subpopulations. In contrast, random sampling does not provide strong guarantees for capture of a rare subpopulation. We also preserve the relative density across the dataset as more representatives will be generated from high-density regions. This simplifies the interpretation of analysis results generated from the subsetted dataset. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aba8c99956dc466841c902a938cd01d31" name="aba8c99956dc466841c902a938cd01d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8c99956dc466841c902a938cd01d31">&#9670;&#160;</a></span>set_num_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a> &amp; scran::DownsampleByNeighbors::set_num_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code><a class="el" href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html#ae9d8590d702e5ddcb55a74b14bf65cad">Defaults::num_neighbors</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of neighbors to use for downsampling. Larger values result in more downsampling, at the cost of some speed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html" title="Downsample a dataset based on its neighbors.">DownsampleByNeighbors</a></code> object.</dd></dl>
<p>Note that this is only used in <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a3fefac1ba6a166d97e525ba63593fddd">run()</a></code> when a list of neighbors is not supplied. </p>

</div>
</div>
<a id="a6891a8dc59fe89d40cf4915da4a15fd1" name="a6891a8dc59fe89d40cf4915da4a15fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6891a8dc59fe89d40cf4915da4a15fd1">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a> &amp; scran::DownsampleByNeighbors::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html#a29317eaf1d45bde61a807c8b97a0854d">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use for neighbor detection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html" title="Downsample a dataset based on its neighbors.">DownsampleByNeighbors</a></code> object.</dd></dl>
<p>Note that this is only used in <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a3fefac1ba6a166d97e525ba63593fddd">run()</a></code> when a list of neighbors is not supplied. </p>

</div>
</div>
<a id="a6b5993d8df83b1a4dd8e0dc1ff42ee45" name="a6b5993d8df83b1a4dd8e0dc1ff42ee45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5993d8df83b1a4dd8e0dc1ff42ee45">&#9670;&#160;</a></span>set_approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1DownsampleByNeighbors.html">DownsampleByNeighbors</a> &amp; scran::DownsampleByNeighbors::set_approximate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structscran_1_1DownsampleByNeighbors_1_1Defaults.html#a217dc2cf9a3fb84e137360a078b0ea49">Defaults::approximate</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Whether approximate neighbor detection should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html" title="Downsample a dataset based on its neighbors.">DownsampleByNeighbors</a></code> object.</dd></dl>
<p>Note that this is only used in <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html#a3fefac1ba6a166d97e525ba63593fddd">run()</a></code> when a data matrix is supplied. </p>

</div>
</div>
<a id="a3fefac1ba6a166d97e525ba63593fddd" name="a3fefac1ba6a166d97e525ba63593fddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fefac1ba6a166d97e525ba63593fddd">&#9670;&#160;</a></span>run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; scran::DownsampleByNeighbors::run </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; Index, Float &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>assigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">neighbors</td><td>Vector of vector of neighbors for each cell. Each entry of the outer vector corresponds to a cell, and each inner vector contains the index and distance of its nearest neighbors. It is assumed that each inner vector is sorted by increasing distance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assigned</td><td>Vector of length equal to the number of cells in <code>neighbors</code>. On completion, this contains the index of the representative for each cell in the original dataset. <code>assigned</code> may also be a null pointer, in which case nothing is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices of the chosen representative cells. The length of this vector depends on the dataset and the specified number of neighbors in <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html#aba8c99956dc466841c902a938cd01d31">set_num_neighbors()</a></code>. Indices are sorted in increasing order. </dd></dl>

</div>
</div>
<a id="a3b88cc9e50826fe0a399c3a9f15e3361" name="a3b88cc9e50826fe0a399c3a9f15e3361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b88cc9e50826fe0a399c3a9f15e3361">&#9670;&#160;</a></span>run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; scran::DownsampleByNeighbors::run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>assigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nobs</td><td>Number of observations, i.e., cells. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Pointer to a column-major array of dimensions (rows) by cells (columns) containing coordinates for each cell, typically in some kind of embedding. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assigned</td><td>Vector of length equal to the number of cells in <code>neighbors</code>. On completion, this contains the index of the representative for each cell in the original dataset. <code>assigned</code> may also be a null pointer, in which case nothing is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices of the chosen representative cells. The length of this vector depends on the dataset and the specified number of neighbors in <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html#aba8c99956dc466841c902a938cd01d31">set_num_neighbors()</a></code>. Indices are sorted in increasing order. </dd></dl>

</div>
</div>
<a id="a582b257a8a333ffc4ae94ae3288055f2" name="a582b257a8a333ffc4ae94ae3288055f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582b257a8a333ffc4ae94ae3288055f2">&#9670;&#160;</a></span>run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename Float &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index &gt; scran::DownsampleByNeighbors::run </td>
          <td>(</td>
          <td class="paramtype">const knncolle::Base&lt; Index, Float &gt; *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index *&#160;</td>
          <td class="paramname"><em>assigned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">index</td><td>Pointer to a <code>knncolle::Base</code> index object, containing a pre-built neighbor index for a dataset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assigned</td><td>Vector of length equal to the number of cells in <code>neighbors</code>. On completion, this contains the index of the representative for each cell in the original dataset. <code>assigned</code> may also be a null pointer, in which case nothing is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of indices of the chosen representative cells. The length of this vector depends on the dataset and the specified number of neighbors in <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html#aba8c99956dc466841c902a938cd01d31">set_num_neighbors()</a></code>. Indices are sorted in increasing order. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/aggregation/<a class="el" href="DownsampleByNeighbors_8hpp_source.html">DownsampleByNeighbors.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
