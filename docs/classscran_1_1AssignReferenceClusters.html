<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::AssignReferenceClusters Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1AssignReferenceClusters-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::AssignReferenceClusters Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Assign cells to their closest reference cluster.  
 <a href="classscran_1_1AssignReferenceClusters.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AssignReferenceClusters_8hpp_source.html">AssignReferenceClusters.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html" title="Results of the cluster assignment.">Results</a> of the cluster assignment.  <a href="structscran_1_1AssignReferenceClusters_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2dab0c03572fafcf3f36ef6650de4d2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a2dab0c03572fafcf3f36ef6650de4d2c">set_num_neighbors</a> (int n=<a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a11e256932564bf2a1f740994d9af7428">Defaults::num_neighbors</a>)</td></tr>
<tr class="separator:a2dab0c03572fafcf3f36ef6650de4d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab38f0aaa22ad854580dd327ed9200ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#aab38f0aaa22ad854580dd327ed9200ca">set_num_threads</a> (int n=<a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a9b5045a586478d126a3cae31250f19b7">Defaults::num_threads</a>)</td></tr>
<tr class="separator:aab38f0aaa22ad854580dd327ed9200ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd20ccb640ac8ed19009261f6e02426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a1bd20ccb640ac8ed19009261f6e02426">set_approximate</a> (int a=<a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a8c33bb06ce4b8595d837cc57d14f090d">Defaults::approximate</a>)</td></tr>
<tr class="separator:a1bd20ccb640ac8ed19009261f6e02426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a034eeb3246b87f6db4358a7ddeb00f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a7a034eeb3246b87f6db4358a7ddeb00f">set_report_best</a> (bool r=<a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#ae6d811c625521328dc56f5b451bd86ad">Defaults::report_best</a>)</td></tr>
<tr class="separator:a7a034eeb3246b87f6db4358a7ddeb00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3de29f07c202d7e450abffcf5321fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a6e3de29f07c202d7e450abffcf5321fa">set_report_second</a> (bool r=<a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a9c3c7e5cda9249a443516f81239911d5">Defaults::report_second</a>)</td></tr>
<tr class="separator:a6e3de29f07c202d7e450abffcf5321fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc235c170b5edf5a86860864793511"><td class="memTemplParams" colspan="2">template&lt;typename Index  = int, typename Float , typename Cluster &gt; </td></tr>
<tr class="memitem:af7bc235c170b5edf5a86860864793511"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#af7bc235c170b5edf5a86860864793511">run</a> (int ndim, size_t nref, const Float *ref, const Cluster *clusters, size_t ntest, const Float *test, Cluster *assigned, Float *best_prop, Float *second_prop) const</td></tr>
<tr class="separator:af7bc235c170b5edf5a86860864793511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aafc63c60a7c1e827069ab94d16166a"><td class="memTemplParams" colspan="2">template&lt;typename Index  = int, typename Float , typename Cluster &gt; </td></tr>
<tr class="memitem:a3aafc63c60a7c1e827069ab94d16166a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a3aafc63c60a7c1e827069ab94d16166a">run</a> (const knncolle::Base&lt; Index, Float &gt; *index, const Cluster *clusters, size_t ntest, const Float *test, Cluster *assigned, Float *best_prop, Float *second_prop) const</td></tr>
<tr class="separator:a3aafc63c60a7c1e827069ab94d16166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851bee5059a5596eb234c2daf67bf0b3"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Float , typename Cluster &gt; </td></tr>
<tr class="memitem:a851bee5059a5596eb234c2daf67bf0b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a851bee5059a5596eb234c2daf67bf0b3">run</a> (const std::vector&lt; std::vector&lt; std::pair&lt; Index, Float &gt; &gt; &gt; &amp;neighbors, size_t nref, const Cluster *clusters, Cluster *assigned, Float *best_prop, Float *second_prop) const</td></tr>
<tr class="separator:a851bee5059a5596eb234c2daf67bf0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce7ca82403a22c9108a891ef56eb2a5"><td class="memTemplParams" colspan="2">template&lt;typename Index  = int, typename Float , typename Cluster &gt; </td></tr>
<tr class="memitem:abce7ca82403a22c9108a891ef56eb2a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html">Results</a>&lt; Float, Cluster &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#abce7ca82403a22c9108a891ef56eb2a5">run</a> (int ndim, size_t nref, const Float *ref, const Cluster *clusters, size_t ntest, const Float *test) const</td></tr>
<tr class="separator:abce7ca82403a22c9108a891ef56eb2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eb52140d81c7a9a5a769339a472a02"><td class="memTemplParams" colspan="2">template&lt;typename Index  = int, typename Float , typename Cluster &gt; </td></tr>
<tr class="memitem:a15eb52140d81c7a9a5a769339a472a02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html">Results</a>&lt; Float, Cluster &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a15eb52140d81c7a9a5a769339a472a02">run</a> (const knncolle::Base&lt; Index, Float &gt; *index, const Cluster *clusters, size_t ntest, const Float *test) const</td></tr>
<tr class="separator:a15eb52140d81c7a9a5a769339a472a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827dd926c8c7ee363927c5d8bd7151c9"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename Float , typename Cluster &gt; </td></tr>
<tr class="memitem:a827dd926c8c7ee363927c5d8bd7151c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html">Results</a>&lt; Float, Cluster &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1AssignReferenceClusters.html#a827dd926c8c7ee363927c5d8bd7151c9">run</a> (const std::vector&lt; std::vector&lt; std::pair&lt; Index, Float &gt; &gt; &gt; &amp;neighbors, size_t nref, const Cluster *clusters)</td></tr>
<tr class="separator:a827dd926c8c7ee363927c5d8bd7151c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Assign cells to their closest reference cluster. </p>
<p >This class assigns the test cell to the most frequent cluster among its neighbors in the reference dataset. The reference dataset is usually generated as a subset of the test dataset, e.g., using <code><a class="el" href="classscran_1_1DownsampleByNeighbors.html" title="Downsample a dataset based on its neighbors.">DownsampleByNeighbors</a></code>. In this manner, we can quickly cluster on the subset and then propagate assignments back to the full dataset.</p>
<p >Admittedly, this is not the most "correct" approach for reference assignment as it favors abundant clusters that are more likely to achieve a majority. Nonetheless, we use it because (i) it's fast and (ii) any inaccuracies near the cluster boundaries are acceptable given that the boundaries are arbitrary anyway. A more accurate approach would be to use <b>singlepp</b>-like classification but this is very slow for single-cell reference datasets.</p>
<p >Note that this function expects low-dimensional coordinates for neighbor searching. See <a href="https://ltla.github.io/singlepp"><b>singlepp</b></a> for classification based on the original count matrix instead. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a15eb52140d81c7a9a5a769339a472a02" name="a15eb52140d81c7a9a5a769339a472a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15eb52140d81c7a9a5a769339a472a02">&#9670;&nbsp;</a></span>run() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float , typename Cluster &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html">Results</a>&lt; Float, Cluster &gt; scran::AssignReferenceClusters::run </td>
          <td>(</td>
          <td class="paramtype">const knncolle::Base&lt; Index, Float &gt; *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cluster *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ntest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign cells in the test dataset to reference clusters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the cell indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances. </td></tr>
    <tr><td class="paramname">Cluster</td><td>Integer type for the cluster assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">index</td><td>Pointer to a <code>knncolle::Base</code> neighbor search index, constructed from the reference dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to an array of length equal to <code>nref</code>, containing the cluster assignment for each cell in the reference. All integers in $[0, N)$ should be present at least once, where $N$ is the total number of unique clusters. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ntest</td><td>Number of cells in the test dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test</td><td>Pointer to a column-major array of coordinates of dimensions (rows) and cells (columns) for the test dataset. This should be a low-dimensional embedding in the same space as the reference dataset used to construct <code>index</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html" title="Results of the cluster assignment.">Results</a></code> object containing the cluster assignment results for each cell in the test dataset. </dd></dl>

</div>
</div>
<a id="a3aafc63c60a7c1e827069ab94d16166a" name="a3aafc63c60a7c1e827069ab94d16166a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aafc63c60a7c1e827069ab94d16166a">&#9670;&nbsp;</a></span>run() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float , typename Cluster &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::AssignReferenceClusters::run </td>
          <td>(</td>
          <td class="paramtype">const knncolle::Base&lt; Index, Float &gt; *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cluster *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ntest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cluster *&#160;</td>
          <td class="paramname"><em>assigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>best_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>second_prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign cells in the test dataset to reference clusters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the cell indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances. </td></tr>
    <tr><td class="paramname">Cluster</td><td>Integer type for the cluster assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">index</td><td>Pointer to a <code>knncolle::Base</code> neighbor search index, constructed from the reference dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to an array of length equal to <code>nref</code>, containing the cluster assignment for each cell in the reference. All integers in $[0, N)$ should be present at least once, where $N$ is the total number of unique clusters. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ntest</td><td>Number of cells in the test dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test</td><td>Pointer to a column-major array of coordinates of dimensions (rows) and cells (columns) for the test dataset. This should be a low-dimensional embedding in the same space as the reference dataset used to construct <code>index</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assigned</td><td>Pointer to an array of length equal to <code>ntest</code>. On output, this is filled with the cluster assignments for each cell in the test dataset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best_prop</td><td>Pointer to an array of length equal to <code>ntest</code>. On output, this is filled with the proportion of neighbors supporting the cluster assignment in <code>assigned</code>. If <code>NULL</code>, this value is not saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">second_prop</td><td>Pointer to an array of length equal to <code>ntest</code>. On output, this is filled with the second-highest proportion of neighbors for a cluster other than the one reported in <code>assigned</code>. If <code>NULL</code>, this value is not saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a827dd926c8c7ee363927c5d8bd7151c9" name="a827dd926c8c7ee363927c5d8bd7151c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827dd926c8c7ee363927c5d8bd7151c9">&#9670;&nbsp;</a></span>run() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename Float , typename Cluster &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html">Results</a>&lt; Float, Cluster &gt; scran::AssignReferenceClusters::run </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; Index, Float &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cluster *&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign cells in the test dataset to reference clusters based on pre-built search indices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the cell indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances. </td></tr>
    <tr><td class="paramname">Cluster</td><td>Integer type for the cluster assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">neighbors</td><td>Precomputed neighbors for each test cell. The outer vector should have length equal to the number of cells in the test dataset. Each inner vector contains the neighbors for the corresponding test cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nref</td><td>Number of cells in the reference dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to an array of length equal to <code>nref</code>, containing the cluster assignment for each cell in the reference. All integers in $[0, N)$ should be present at least once, where $N$ is the total number of unique clusters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html" title="Results of the cluster assignment.">Results</a></code> object containing the cluster assignment results for each cell in the test dataset. </dd></dl>

</div>
</div>
<a id="a851bee5059a5596eb234c2daf67bf0b3" name="a851bee5059a5596eb234c2daf67bf0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851bee5059a5596eb234c2daf67bf0b3">&#9670;&nbsp;</a></span>run() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename Float , typename Cluster &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::AssignReferenceClusters::run </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::pair&lt; Index, Float &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cluster *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cluster *&#160;</td>
          <td class="paramname"><em>assigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>best_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>second_prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign cells in the test dataset to reference clusters based on pre-built search indices.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the cell indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances. </td></tr>
    <tr><td class="paramname">Cluster</td><td>Integer type for the cluster assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">neighbors</td><td>Precomputed neighbors for each test cell. The outer vector should have length equal to the number of cells in the test dataset. Each inner vector contains the neighbors for the corresponding test cell. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nref</td><td>Number of cells in the reference dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to an array of length equal to <code>nref</code>, containing the cluster assignment for each cell in the reference. All integers in $[0, N)$ should be present at least once, where $N$ is the total number of unique clusters. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assigned</td><td>Pointer to an array of length equal to <code>neighbors.size()</code>. On output, this is filled with the cluster assignments for each cell in the test dataset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best_prop</td><td>Pointer to an array of length equal to <code>neighbors.size()</code>. On output, this is filled with the proportion of neighbors supporting the cluster assignment in <code>assigned</code>. If <code>NULL</code>, this value is not saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">second_prop</td><td>Pointer to an array of length equal to <code>neighbors.size()</code>. On output, this is filled with the second-highest proportion of neighbors for a cluster other than the one reported in <code>assigned</code>. If <code>NULL</code>, this value is not saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abce7ca82403a22c9108a891ef56eb2a5" name="abce7ca82403a22c9108a891ef56eb2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce7ca82403a22c9108a891ef56eb2a5">&#9670;&nbsp;</a></span>run() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float , typename Cluster &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html">Results</a>&lt; Float, Cluster &gt; scran::AssignReferenceClusters::run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cluster *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ntest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign cells in the test dataset to reference clusters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the cell indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances. </td></tr>
    <tr><td class="paramname">Cluster</td><td>Integer type for the cluster assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nref</td><td>Number of cells in the reference dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>Pointer to a column-major array of coordinates of dimensions (rows) and cells (columns) for the reference dataset. This should be a low-dimensional embedding, e.g., from <code><a class="el" href="classscran_1_1RunPCA.html" title="Perform PCA on a gene-cell matrix.">RunPCA</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to an array of length equal to <code>nref</code>, containing the cluster assignment for each cell in the reference. All integers in $[0, N)$ should be present at least once, where $N$ is the total number of unique clusters. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ntest</td><td>Number of cells in the test dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test</td><td>Pointer to a column-major array of coordinates of dimensions (rows) and cells (columns) for the test dataset. This should be a low-dimensional embedding in the same space as <code>ref</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Results.html" title="Results of the cluster assignment.">Results</a></code> object containing the cluster assignment results for each cell in the test dataset. </dd></dl>

</div>
</div>
<a id="af7bc235c170b5edf5a86860864793511" name="af7bc235c170b5edf5a86860864793511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bc235c170b5edf5a86860864793511">&#9670;&nbsp;</a></span>run() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index  = int, typename Float , typename Cluster &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scran::AssignReferenceClusters::run </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cluster *&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ntest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cluster *&#160;</td>
          <td class="paramname"><em>assigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>best_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Float *&#160;</td>
          <td class="paramname"><em>second_prop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Assign cells in the test dataset to reference clusters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integer type for the cell indices. </td></tr>
    <tr><td class="paramname">Float</td><td>Floating point type for the distances. </td></tr>
    <tr><td class="paramname">Cluster</td><td>Integer type for the cluster assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ndim</td><td>Number of dimensions. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nref</td><td>Number of cells in the reference dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ref</td><td>Pointer to a column-major array of coordinates of dimensions (rows) and cells (columns) for the reference dataset. This should be a low-dimensional embedding, e.g., from <code><a class="el" href="classscran_1_1RunPCA.html" title="Perform PCA on a gene-cell matrix.">RunPCA</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clusters</td><td>Pointer to an array of length equal to <code>nref</code>, containing the cluster assignment for each cell in the reference. All integers in $[0, N)$ should be present at least once, where $N$ is the total number of unique clusters. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ntest</td><td>Number of cells in the test dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test</td><td>Pointer to a column-major array of coordinates of dimensions (rows) and cells (columns) for the test dataset. This should be a low-dimensional embedding in the same space as <code>ref</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">assigned</td><td>Pointer to an array of length equal to <code>ntest</code>. On output, this is filled with the cluster assignments for each cell in the test dataset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">best_prop</td><td>Pointer to an array of length equal to <code>ntest</code>. On output, this is filled with the proportion of neighbors supporting the cluster assignment in <code>assigned</code>. If <code>NULL</code>, this value is not saved. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">second_prop</td><td>Pointer to an array of length equal to <code>ntest</code>. On output, this is filled with the second-highest proportion of neighbors for a cluster other than the one reported in <code>assigned</code>. If <code>NULL</code>, this value is not saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd20ccb640ac8ed19009261f6e02426" name="a1bd20ccb640ac8ed19009261f6e02426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd20ccb640ac8ed19009261f6e02426">&#9670;&nbsp;</a></span>set_approximate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp; scran::AssignReferenceClusters::set_approximate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a8c33bb06ce4b8595d837cc57d14f090d">Defaults::approximate</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Whether approximate neighbor detection should be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AssignReferenceClusters.html" title="Assign cells to their closest reference cluster.">AssignReferenceClusters</a></code> object. </dd></dl>

</div>
</div>
<a id="a2dab0c03572fafcf3f36ef6650de4d2c" name="a2dab0c03572fafcf3f36ef6650de4d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dab0c03572fafcf3f36ef6650de4d2c">&#9670;&nbsp;</a></span>set_num_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp; scran::AssignReferenceClusters::set_num_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a11e256932564bf2a1f740994d9af7428">Defaults::num_neighbors</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Number of neighbors to use for assigning a cluster. Smaller values focus more on the local neighborhood around each test cell, while larger values focus on the behavior of the bulk of the cluster.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AssignReferenceClusters.html" title="Assign cells to their closest reference cluster.">AssignReferenceClusters</a></code> object. </dd></dl>

</div>
</div>
<a id="aab38f0aaa22ad854580dd327ed9200ca" name="aab38f0aaa22ad854580dd327ed9200ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab38f0aaa22ad854580dd327ed9200ca">&#9670;&nbsp;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp; scran::AssignReferenceClusters::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a9b5045a586478d126a3cae31250f19b7">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use for neighbor detection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AssignReferenceClusters.html" title="Assign cells to their closest reference cluster.">AssignReferenceClusters</a></code> object. </dd></dl>

</div>
</div>
<a id="a7a034eeb3246b87f6db4358a7ddeb00f" name="a7a034eeb3246b87f6db4358a7ddeb00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a034eeb3246b87f6db4358a7ddeb00f">&#9670;&nbsp;</a></span>set_report_best()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp; scran::AssignReferenceClusters::set_report_best </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#ae6d811c625521328dc56f5b451bd86ad">Defaults::report_best</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Whether to report the proportion of the best cluster for each cell. This can be a useful diagnostic to remove poor assignments when the best proportion is low.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AssignReferenceClusters.html" title="Assign cells to their closest reference cluster.">AssignReferenceClusters</a></code> object. </dd></dl>

</div>
</div>
<a id="a6e3de29f07c202d7e450abffcf5321fa" name="a6e3de29f07c202d7e450abffcf5321fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3de29f07c202d7e450abffcf5321fa">&#9670;&nbsp;</a></span>set_report_second()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1AssignReferenceClusters.html">AssignReferenceClusters</a> &amp; scran::AssignReferenceClusters::set_report_second </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structscran_1_1AssignReferenceClusters_1_1Defaults.html#a9c3c7e5cda9249a443516f81239911d5">Defaults::report_second</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Whether to report the proportion of the second-best cluster for each cell. This can be a useful diagnostic to remove ambiguous assignments when the second-best proportion is close to the best proportion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1AssignReferenceClusters.html" title="Assign cells to their closest reference cluster.">AssignReferenceClusters</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/clustering/<a class="el" href="AssignReferenceClusters_8hpp_source.html">AssignReferenceClusters.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
