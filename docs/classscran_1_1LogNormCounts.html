<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::LogNormCounts Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1LogNormCounts-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">scran::LogNormCounts Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Compute log-normalized expression values.  
 <a href="classscran_1_1LogNormCounts.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LogNormCounts_8hpp_source.html">LogNormCounts.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a77b3a4d60721ae2a2a7fa4d682fc6dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a77b3a4d60721ae2a2a7fa4d682fc6dd3">set_pseudo_count</a> (double p=1)</td></tr>
<tr class="separator:a77b3a4d60721ae2a2a7fa4d682fc6dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78f6693201a9a1778891a57a38dc356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#aa78f6693201a9a1778891a57a38dc356">set_center</a> (bool c=true)</td></tr>
<tr class="separator:aa78f6693201a9a1778891a57a38dc356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a50352164009a0f0fb9e1457bac463c"><td class="memTemplParams" colspan="2">template&lt;class MAT , class V &gt; </td></tr>
<tr class="memitem:a2a50352164009a0f0fb9e1457bac463c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a2a50352164009a0f0fb9e1457bac463c">run</a> (std::shared_ptr&lt; MAT &gt; mat, V size_factors)</td></tr>
<tr class="separator:a2a50352164009a0f0fb9e1457bac463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1453a3512e626d22baa2e96ab550c4"><td class="memTemplParams" colspan="2">template&lt;class MAT , class V , typename B &gt; </td></tr>
<tr class="memitem:a5f1453a3512e626d22baa2e96ab550c4"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; MAT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1LogNormCounts.html#a5f1453a3512e626d22baa2e96ab550c4">run_blocked</a> (std::shared_ptr&lt; MAT &gt; mat, V size_factors, const B *block)</td></tr>
<tr class="separator:a5f1453a3512e626d22baa2e96ab550c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compute log-normalized expression values. </p>
<p>Given a count matrix and a set of size factors, compute log-transformed normalized expression values. Each cell's counts are divided by the cell's size factor, to account for differences in capture efficiency and sequencing depth across cells. The normalized values are then log-transformed so that downstream analyses focus on the relative rather than absolute differences in expression; this process also provides some measure of variance stabilization. These operations are done in a delayed manner using the <code>DelayedIsometricOp</code> class from the <b>tatami</b> library. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2a50352164009a0f0fb9e1457bac463c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a50352164009a0f0fb9e1457bac463c">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;MAT&gt; scran::LogNormCounts::run </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>size_factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute log-normalized expression values from an input matrix. To avoid copying the data, this is done in a delayed manner using the <code>DelayedIsometricOp</code> class from the <b>tatami</b> package.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td><code>tatami::typed_matrix</code>, most typically a <code>tatami::numeric_matrix</code>. </td></tr>
    <tr><td class="paramname">V</td><td>A vector class supporting <code>size()</code>, random access via <code>[</code>, <code>begin()</code>, <code>end()</code> and <code>data()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Pointer to an input count matrix, with features in the rows and cells in the columns. </td></tr>
    <tr><td class="paramname">size_factors</td><td>A vector of positive size factors, of length equal to the number of columns in <code>mat</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a matrix of log-transformed and normalized values. </dd></dl>

</div>
</div>
<a id="a5f1453a3512e626d22baa2e96ab550c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1453a3512e626d22baa2e96ab550c4">&#9670;&nbsp;</a></span>run_blocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MAT , class V , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;MAT&gt; scran::LogNormCounts::run_blocked </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; MAT &gt;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>size_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute log-normalized expression values from an input matrix with blocking. Specifically, centering of size factors is performed within each block. This allows users to easily mimic normalization of different blocks of cells (e.g., from different samples) in the same matrix. In contrast, without blocking, the centering would depend on the size factors in different blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MAT</td><td><code>tatami::typed_matrix</code>, most typically a <code>tatami::numeric_matrix</code>. </td></tr>
    <tr><td class="paramname">V</td><td>A vector class supporting <code>size()</code>, random access via <code>[</code>, <code>begin()</code>, <code>end()</code> and <code>data()</code>. </td></tr>
    <tr><td class="paramname">B</td><td>An integer type, to hold the block IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mat</td><td>Pointer to an input count matrix, with features in the rows and cells in the columns. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size_factors</td><td>A vector of positive size factors, of length equal to the number of columns in <code>mat</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of block identifiers. If provided, the array should be of length equal to the number of columns in <code>mat</code>. Values should be integer IDs in <img class="formulaInl" alt="$[0, N)$" src="form_0.png"/> where <img class="formulaInl" alt="$N$" src="form_1.png"/> is the number of blocks. This can also be a <code>NULL</code>, in which case all cells are assumed to belong to the same block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a matrix of log-transformed and normalized values. </dd></dl>

</div>
</div>
<a id="aa78f6693201a9a1778891a57a38dc356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78f6693201a9a1778891a57a38dc356">&#9670;&nbsp;</a></span>set_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a>&amp; scran::LogNormCounts::set_center </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>c</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify whether to center the size factors in <code><a class="el" href="classscran_1_1LogNormCounts.html#a2a50352164009a0f0fb9e1457bac463c">run()</a></code>. If <code>true</code>, we center the size factors across cells so that their average is equal to 1; this ensures that the normalized values can still be interpreted on the same scale as the input counts.</p>
<p>If <code>false</code>, no further centering is performed. This is more efficient when size factors are already centered; it may also be useful for re-using this class to compute other normalized values like log-CPMs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Whether to center the size factors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<a id="a77b3a4d60721ae2a2a7fa4d682fc6dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b3a4d60721ae2a2a7fa4d682fc6dd3">&#9670;&nbsp;</a></span>set_pseudo_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1LogNormCounts.html">LogNormCounts</a>&amp; scran::LogNormCounts::set_pseudo_count </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the pseudo-count for the log-transformation. This avoids problems with undefined values at zero counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pseudo-count, should be a positive number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1LogNormCounts.html" title="Compute log-normalized expression values.">LogNormCounts</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/normalization/<a class="el" href="LogNormCounts_8hpp_source.html">LogNormCounts.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
