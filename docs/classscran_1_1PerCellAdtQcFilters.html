<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::PerCellAdtQcFilters Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>scran</b></li><li class="navelem"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1PerCellAdtQcFilters-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::PerCellAdtQcFilters Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Create filters to identify low-quality cells from ADT data.  
 <a href="classscran_1_1PerCellAdtQcFilters.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PerCellAdtQcFilters_8hpp_source.html">PerCellAdtQcFilters.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html" title="Results of the QC filtering.">Results</a> of the QC filtering.  <a href="structscran_1_1PerCellAdtQcFilters_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html">Thresholds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html" title="Thresholds to define outliers on each metric.">Thresholds</a> to define outliers on each metric.  <a href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e2de1a5ce0fc3d34e62a807e07f6900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a9e2de1a5ce0fc3d34e62a807e07f6900">set_nmads</a> (double n=<a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aaa64ec4b75ea7d041100630fc9a06092">Defaults::nmads</a>)</td></tr>
<tr class="separator:a9e2de1a5ce0fc3d34e62a807e07f6900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cacdef37109dd3bd0052e7da577b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a49cacdef37109dd3bd0052e7da577b10">set_detected_nmads</a> (double n=<a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aaa64ec4b75ea7d041100630fc9a06092">Defaults::nmads</a>)</td></tr>
<tr class="separator:a49cacdef37109dd3bd0052e7da577b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b86e5216272a6fab3f69bed62ddc37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a94b86e5216272a6fab3f69bed62ddc37">set_subset_nmads</a> (double n=<a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aaa64ec4b75ea7d041100630fc9a06092">Defaults::nmads</a>)</td></tr>
<tr class="separator:a94b86e5216272a6fab3f69bed62ddc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054481ecf65cfe2d7d6ae919ba5ce457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a054481ecf65cfe2d7d6ae919ba5ce457">set_min_detected_drop</a> (double m=<a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aa229e997491d3190175097269e3d98d1">Defaults::min_detected_drop</a>)</td></tr>
<tr class="separator:a054481ecf65cfe2d7d6ae919ba5ce457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81d4a291d0f34a04050f68e68908231"><td class="memTemplParams" colspan="2">template&lt;typename D , typename PPTR , typename X &gt; </td></tr>
<tr class="memitem:af81d4a291d0f34a04050f68e68908231"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html">Thresholds</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#af81d4a291d0f34a04050f68e68908231">run</a> (size_t ncells, const D *detected, std::vector&lt; PPTR &gt; subset_totals, X *filter_by_detected, std::vector&lt; X * &gt; filter_by_subset_totals, X *overall_filter) const</td></tr>
<tr class="separator:af81d4a291d0f34a04050f68e68908231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02911734665fb374a9e726c5eda67e2f"><td class="memTemplParams" colspan="2">template&lt;typename B , typename D , typename PPTR , typename X &gt; </td></tr>
<tr class="memitem:a02911734665fb374a9e726c5eda67e2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html">Thresholds</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a02911734665fb374a9e726c5eda67e2f">run_blocked</a> (size_t ncells, const B *block, const D *detected, std::vector&lt; PPTR &gt; subset_totals, X *filter_by_detected, std::vector&lt; X * &gt; filter_by_subset_totals, X *overall_filter) const</td></tr>
<tr class="separator:a02911734665fb374a9e726c5eda67e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e30ae6284394803e3eb85b00e180ec"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, typename D , typename PPTR &gt; </td></tr>
<tr class="memitem:ac8e30ae6284394803e3eb85b00e180ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#ac8e30ae6284394803e3eb85b00e180ec">run</a> (size_t ncells, const D *detected, std::vector&lt; PPTR &gt; subset_totals) const</td></tr>
<tr class="separator:ac8e30ae6284394803e3eb85b00e180ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc97f197029caa60d9ad36f9b5c7cb9"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, typename B , typename D , typename PPTR &gt; </td></tr>
<tr class="memitem:a7fc97f197029caa60d9ad36f9b5c7cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a7fc97f197029caa60d9ad36f9b5c7cb9">run_blocked</a> (size_t ncells, const B *block, const D *detected, std::vector&lt; PPTR &gt; subset_totals) const</td></tr>
<tr class="separator:a7fc97f197029caa60d9ad36f9b5c7cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405e6652ffb1bdefd3b281d9cb5af7bb"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, class R &gt; </td></tr>
<tr class="memitem:a405e6652ffb1bdefd3b281d9cb5af7bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a405e6652ffb1bdefd3b281d9cb5af7bb">run</a> (const R &amp;metrics) const</td></tr>
<tr class="separator:a405e6652ffb1bdefd3b281d9cb5af7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820edc332c75537019ac4646025fed71"><td class="memTemplParams" colspan="2">template&lt;typename X  = uint8_t, class R , typename B &gt; </td></tr>
<tr class="memitem:a820edc332c75537019ac4646025fed71"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a820edc332c75537019ac4646025fed71">run_blocked</a> (const R &amp;metrics, const B *block) const</td></tr>
<tr class="separator:a820edc332c75537019ac4646025fed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Create filters to identify low-quality cells from ADT data. </p>
<p >In antibody-derived tag (ADT) count matrices, the QC filtering decisions are slightly different than those for RNA count matrices (see <code><a class="el" href="classscran_1_1PerCellQCFilters.html" title="Create filters to identify low-quality cells.">PerCellQCFilters</a></code> for the latter). Here, low-quality cells are defined as those with:</p>
<ul>
<li>Low numbers of detected features, which indicates that library preparation or sequencing depth was suboptimal. Even in ADT data, we should expect to detect many features in a cell due to ambient contamination.</li>
<li>High total counts in the isotype control (IgG) subsets. The IgG antibodies should not bind to anything, so high coverage is indicative of non-specific binding or antibody conjugates.</li>
</ul>
<p >We define a threshold on each metric based on a certain number of MADs from the median. This assumes that most cells in the experiment are of high (or at least acceptable) quality; any outliers are indicative of low-quality cells that should be filtered out. See the <code><a class="el" href="classscran_1_1IsOutlier.html" title="Define outlier values based on MADs.">IsOutlier</a></code> class for implementation details.</p>
<p >For the total counts and number of detected features, the outliers are defined after log-transformation of the metrics. This improves resolution at low values and ensures that the defined threshold is not negative.</p>
<p >For the number of detected features, we supplement the MAD-based threshold with a minimum drop. Cells are only considered to be low quality if the difference in the number of detected features from the median is greater than a certain percentage. By default, the number must drop by at least 10%; this avoids overly aggressive filtering when the MAD is too low or zero. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a405e6652ffb1bdefd3b281d9cb5af7bb" name="a405e6652ffb1bdefd3b281d9cb5af7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405e6652ffb1bdefd3b281d9cb5af7bb">&#9670;&nbsp;</a></span>run() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, class R &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellAdtQcFilters::run </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>metrics</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from ADT-derived QC metrics, see <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#af81d4a291d0f34a04050f68e68908231">run()</a></code> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">R</td><td>Class that holds the QC metrics, typically a <code><a class="el" href="structscran_1_1PerCellAdtQcMetrics_1_1Results.html" title="Result store for QC metric calculations.">PerCellAdtQcMetrics::Results</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metrics</td><td>Precomputed QC metrics, typically generated by <code><a class="el" href="classscran_1_1PerCellAdtQcMetrics.html#a66a311ed31fa3856867ea7918c4b982e">PerCellAdtQcMetrics::run</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="ac8e30ae6284394803e3eb85b00e180ec" name="ac8e30ae6284394803e3eb85b00e180ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e30ae6284394803e3eb85b00e180ec">&#9670;&nbsp;</a></span>run() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, typename D , typename PPTR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellAdtQcFilters::run </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_totals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from ADT-derived QC metrics, see <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#af81d4a291d0f34a04050f68e68908231">run()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">D</td><td>Type of the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Type of the pointer to the subset totals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_totals</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the total counts in that subset for each cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="af81d4a291d0f34a04050f68e68908231" name="af81d4a291d0f34a04050f68e68908231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81d4a291d0f34a04050f68e68908231">&#9670;&nbsp;</a></span>run() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , typename PPTR , typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html">Thresholds</a> scran::PerCellAdtQcFilters::run </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_totals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>filter_by_detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; X * &gt;&#160;</td>
          <td class="paramname"><em>filter_by_subset_totals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>overall_filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells based on QC metrics computed from the ADT count data, typically using the <code><a class="el" href="classscran_1_1PerCellAdtQcMetrics.html" title="Compute per-cell quality control metrics from an ADT count matrix.">PerCellAdtQcMetrics</a></code> class.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>Integer type, used for the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Pointer to a floating point type, for the subset totals. </td></tr>
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_totals</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the total count in that subset for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_detected</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a low number of detected features. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_subset_totals</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a high total count for that subset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">overall_filter</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out for any reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html" title="Thresholds to define outliers on each metric.">Thresholds</a></code> object defining the thresholds for each QC metric. </dd></dl>

</div>
</div>
<a id="a820edc332c75537019ac4646025fed71" name="a820edc332c75537019ac4646025fed71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820edc332c75537019ac4646025fed71">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, class R , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellAdtQcFilters::run_blocked </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from QC metrics with blocking, see <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a02911734665fb374a9e726c5eda67e2f">run_blocked()</a></code> for details.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">R</td><td>Class that holds the QC metrics, typically a <code><a class="el" href="structscran_1_1PerCellAdtQcMetrics_1_1Results.html" title="Result store for QC metric calculations.">PerCellAdtQcMetrics::Results</a></code>. </td></tr>
    <tr><td class="paramname">B</td><td>Integer type, to hold the block IDs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">metrics</td><td>Precomputed QC metrics, typically generated by <code><a class="el" href="classscran_1_1PerCellAdtQcMetrics.html#a66a311ed31fa3856867ea7918c4b982e">PerCellAdtQcMetrics::run</a></code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Optional pointer to an array of block identifiers, see <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a02911734665fb374a9e726c5eda67e2f">run_blocked()</a></code> for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="a7fc97f197029caa60d9ad36f9b5c7cb9" name="a7fc97f197029caa60d9ad36f9b5c7cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc97f197029caa60d9ad36f9b5c7cb9">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X  = uint8_t, typename B , typename D , typename PPTR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html">Results</a>&lt; X &gt; scran::PerCellAdtQcFilters::run_blocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_totals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from ADT-derived QC metrics with blocking, see <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a02911734665fb374a9e726c5eda67e2f">run_blocked()</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded. </td></tr>
    <tr><td class="paramname">B</td><td>Pointer to an integer type, to hold the block IDs. </td></tr>
    <tr><td class="paramname">D</td><td>Type of the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Type of the pointer to the subset totals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Optional pointer to an array of block identifiers, see <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html#a02911734665fb374a9e726c5eda67e2f">run_blocked()</a></code> for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_totals</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the total count in that subset for each cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Results.html" title="Results of the QC filtering.">Results</a></code> object indicating whether a cell should be filtered out for each reason. </dd></dl>

</div>
</div>
<a id="a02911734665fb374a9e726c5eda67e2f" name="a02911734665fb374a9e726c5eda67e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02911734665fb374a9e726c5eda67e2f">&#9670;&nbsp;</a></span>run_blocked() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename D , typename PPTR , typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html">Thresholds</a> scran::PerCellAdtQcFilters::run_blocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D *&#160;</td>
          <td class="paramname"><em>detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PPTR &gt;&#160;</td>
          <td class="paramname"><em>subset_totals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>filter_by_detected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; X * &gt;&#160;</td>
          <td class="paramname"><em>filter_by_subset_totals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>overall_filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Identify low-quality cells from ADT-derived QC metrics, with blocking during outlier identification. Specifically, outliers are only computed within each block, which is useful when cells in different blocks have different distributions for the QC metrics, e.g., because they were sequenced at different depth. By blocking, we avoid confounding the outlier detection with systematic differences between blocks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>Pointer to an integer type, to hold the block IDs. </td></tr>
    <tr><td class="paramname">D</td><td>Integer type, used for the number of detected features. </td></tr>
    <tr><td class="paramname">PPTR</td><td>Pointer to a floating point type, for the subset totals. </td></tr>
    <tr><td class="paramname">X</td><td>Boolean type to indicate whether a cell should be discarded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ncells</td><td>Number of cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of block identifiers. If provided, the array should be of length equal to <code>ncells</code>. Values should be integer IDs in <img class="formulaInl" alt="$[0, N)$" src="form_0.png"/> where <img class="formulaInl" alt="$N$" src="form_1.png"/> is the number of blocks. This can also be <code>NULL</code>, in which case all cells are assumed to belong to the same block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detected</td><td>Pointer to an array of length equal to <code>ncells</code>, containing the number of detected features for each cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subset_totals</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, containing the total counts in that subset for each cell. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_detected</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a low number of detected features. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_by_subset_totals</td><td>Vector of pointers of length equal to the number of feature subsets. Each pointer corresponds to a feature subset and should point to an array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out due to a high total count for that subset. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">overall_filter</td><td>Pointer to an output array of length equal to <code>ncells</code>, indicating whether a cell should be filtered out for any reason.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Thresholds.html" title="Thresholds to define outliers on each metric.">Thresholds</a></code> object defining the thresholds for each QC metric in each block. </dd></dl>

</div>
</div>
<a id="a49cacdef37109dd3bd0052e7da577b10" name="a49cacdef37109dd3bd0052e7da577b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cacdef37109dd3bd0052e7da577b10">&#9670;&nbsp;</a></span>set_detected_nmads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp; scran::PerCellAdtQcFilters::set_detected_nmads </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aaa64ec4b75ea7d041100630fc9a06092">Defaults::nmads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of MADs from the median, to define the threshold for outliers in the number of detected features. This should be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html" title="Create filters to identify low-quality cells from ADT data.">PerCellAdtQcFilters</a></code> object. </dd></dl>

</div>
</div>
<a id="a054481ecf65cfe2d7d6ae919ba5ce457" name="a054481ecf65cfe2d7d6ae919ba5ce457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054481ecf65cfe2d7d6ae919ba5ce457">&#9670;&nbsp;</a></span>set_min_detected_drop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp; scran::PerCellAdtQcFilters::set_min_detected_drop </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em> = <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aa229e997491d3190175097269e3d98d1">Defaults::min_detected_drop</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Minimum drop in the number of detected features from the median, in order to consider a cell to be of low quality. This should lie in $[0, 1)$.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html" title="Create filters to identify low-quality cells from ADT data.">PerCellAdtQcFilters</a></code> object. </dd></dl>

</div>
</div>
<a id="a9e2de1a5ce0fc3d34e62a807e07f6900" name="a9e2de1a5ce0fc3d34e62a807e07f6900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e2de1a5ce0fc3d34e62a807e07f6900">&#9670;&nbsp;</a></span>set_nmads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp; scran::PerCellAdtQcFilters::set_nmads </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aaa64ec4b75ea7d041100630fc9a06092">Defaults::nmads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of MADs from the median, to define the threshold for outliers. This should be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html" title="Create filters to identify low-quality cells from ADT data.">PerCellAdtQcFilters</a></code> object. </dd></dl>

</div>
</div>
<a id="a94b86e5216272a6fab3f69bed62ddc37" name="a94b86e5216272a6fab3f69bed62ddc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b86e5216272a6fab3f69bed62ddc37">&#9670;&nbsp;</a></span>set_subset_nmads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1PerCellAdtQcFilters.html">PerCellAdtQcFilters</a> &amp; scran::PerCellAdtQcFilters::set_subset_nmads </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1PerCellAdtQcFilters_1_1Defaults.html#aaa64ec4b75ea7d041100630fc9a06092">Defaults::nmads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of MADs from the median, to define the threshold for outliers in the total count for each subset. This should be non-negative.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1PerCellAdtQcFilters.html" title="Create filters to identify low-quality cells from ADT data.">PerCellAdtQcFilters</a></code> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/quality_control/<a class="el" href="PerCellAdtQcFilters_8hpp_source.html">PerCellAdtQcFilters.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
