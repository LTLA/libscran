<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran: scran::MultiBatchPca Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran
   </div>
   <div id="projectbrief">C++ library for basic single-cell RNA-seq analyses</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classscran_1_1MultiBatchPca-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">scran::MultiBatchPca Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Compute PCA after adjusting for differences between batch sizes.  
 <a href="classscran_1_1MultiBatchPca.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MultiBatchPca_8hpp_source.html">MultiBatchPca.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html">Defaults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default parameter settings.  <a href="structscran_1_1MultiBatchPca_1_1Defaults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html">Results</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the PCA results.  <a href="structscran_1_1MultiBatchPca_1_1Results.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a826421c677af500db839f8a18a2c39" id="r_a1a826421c677af500db839f8a18a2c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#a1a826421c677af500db839f8a18a2c39">set_rank</a> (int r=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a248820dc9034a1bafd85a65c2eeca6f4">Defaults::rank</a>)</td></tr>
<tr class="separator:a1a826421c677af500db839f8a18a2c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd83f857848808000f8a1750c950152" id="r_affd83f857848808000f8a1750c950152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#affd83f857848808000f8a1750c950152">set_scale</a> (bool s=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a9dd4b828319c23efbf41857432140fe8">Defaults::scale</a>)</td></tr>
<tr class="separator:affd83f857848808000f8a1750c950152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdb8c1a5db29d6db7e9b63b8f47a46a" id="r_abbdb8c1a5db29d6db7e9b63b8f47a46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#abbdb8c1a5db29d6db7e9b63b8f47a46a">set_transpose</a> (bool t=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a21094170e7bad50d62c41953af91ee14">Defaults::transpose</a>)</td></tr>
<tr class="separator:abbdb8c1a5db29d6db7e9b63b8f47a46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e92f29f42ab49d2a83d756fae75638" id="r_ac2e92f29f42ab49d2a83d756fae75638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#ac2e92f29f42ab49d2a83d756fae75638">set_use_residuals</a> (bool u=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#aeaf151ac0d14f85b26c1acf16dd2eec5">Defaults::use_residuals</a>)</td></tr>
<tr class="separator:ac2e92f29f42ab49d2a83d756fae75638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fd66fbbc86c9ec8be6899a75fa463b" id="r_ab3fd66fbbc86c9ec8be6899a75fa463b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#ab3fd66fbbc86c9ec8be6899a75fa463b">set_block_weight_policy</a> (<a class="el" href="namespacescran.html#abcd041d625290609e221552910ae2c34">WeightPolicy</a> w=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a309917adfb9497416204fb547db3d9b5">Defaults::block_weight_policy</a>)</td></tr>
<tr class="separator:ab3fd66fbbc86c9ec8be6899a75fa463b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe01c3b8a4dc06b7e60ae281af2ce992" id="r_afe01c3b8a4dc06b7e60ae281af2ce992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#afe01c3b8a4dc06b7e60ae281af2ce992">set_variable_block_weight_parameters</a> (<a class="el" href="structscran_1_1VariableBlockWeightParameters.html">VariableBlockWeightParameters</a> v=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#afddd3819171f2d7175b72b27aa3fb54e">Defaults::variable_block_weight_parameters</a>)</td></tr>
<tr class="separator:afe01c3b8a4dc06b7e60ae281af2ce992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6325469e46f9a4dc9a6969d44cab099d" id="r_a6325469e46f9a4dc9a6969d44cab099d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#a6325469e46f9a4dc9a6969d44cab099d">set_return_rotation</a> (bool r=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a290139ceca981fae9c7c5f49b6a6f095">Defaults::return_rotation</a>)</td></tr>
<tr class="separator:a6325469e46f9a4dc9a6969d44cab099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44678f99924f3e0025fb06d88237132" id="r_af44678f99924f3e0025fb06d88237132"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#af44678f99924f3e0025fb06d88237132">set_return_center</a> (bool r=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a4b47e1cdbc323a960c517cc71c9f6a12">Defaults::return_center</a>)</td></tr>
<tr class="separator:af44678f99924f3e0025fb06d88237132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68c3d9595aadac26fe358dfe7a66cbd" id="r_ad68c3d9595aadac26fe358dfe7a66cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#ad68c3d9595aadac26fe358dfe7a66cbd">set_return_scale</a> (bool r=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#aa057739b9f0c851051d2cb1517a7378a">Defaults::return_scale</a>)</td></tr>
<tr class="separator:ad68c3d9595aadac26fe358dfe7a66cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6b9bd782acd3f4d202d287b9204200" id="r_ada6b9bd782acd3f4d202d287b9204200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#ada6b9bd782acd3f4d202d287b9204200">set_num_threads</a> (int n=<a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a36884dec33d2a7cff6ae01ba793dbdde">Defaults::num_threads</a>)</td></tr>
<tr class="separator:ada6b9bd782acd3f4d202d287b9204200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02198e53fecd46289c648e8cf9ddaf7f" id="r_a02198e53fecd46289c648e8cf9ddaf7f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , typename Batch &gt; </td></tr>
<tr class="memitem:a02198e53fecd46289c648e8cf9ddaf7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html">Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#a02198e53fecd46289c648e8cf9ddaf7f">run</a> (const tatami::Matrix&lt; T, IDX &gt; *mat, const Batch *batch) const</td></tr>
<tr class="separator:a02198e53fecd46289c648e8cf9ddaf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b552bdcb748db7dbeb70cec718e706" id="r_af5b552bdcb748db7dbeb70cec718e706"><td class="memTemplParams" colspan="2">template&lt;typename T , typename IDX , typename Batch , typename X &gt; </td></tr>
<tr class="memitem:af5b552bdcb748db7dbeb70cec718e706"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html">Results</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classscran_1_1MultiBatchPca.html#af5b552bdcb748db7dbeb70cec718e706">run</a> (const tatami::Matrix&lt; T, IDX &gt; *mat, const Batch *batch, const X *features) const</td></tr>
<tr class="separator:af5b552bdcb748db7dbeb70cec718e706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Compute PCA after adjusting for differences between batch sizes. </p>
<p>In multi-batch scenarios, we may wish to compute a PCA involving data from multiple batches. However, if one batch has many more cells, it will dominate the PCA by driving the definition of the rotation vectors. This may mask interesting aspects of variation in the smaller batches. To overcome this problem, we scale each batch in inverse proportion to its size. This ensures that each batch contributes equally to the (conceptual) gene-gene covariance matrix, the eigenvectors of which are used as the rotation vectors. Cells are then projected to the subspace defined by these rotation vectors to obtain PC coordinates.</p>
<p>Alternatively, we can compute rotation vectors from the residuals, i.e., after centering each batch. The gene-gene covariance matrix will thus focus on variation within each batch, ensuring that the top PCs capture biological heterogeneity instead of batch effects. (This is particularly important in applications with many batches, where batch effects might otherwise displace biology from the top PCs.) However, unlike <code><a class="el" href="classscran_1_1ResidualPca.html" title="Compute PCA after regressing out an uninteresting factor.">ResidualPca</a></code>, it is important to note that the residuals are only used here for calculating the rotation vectors. We still project the input matrix to obtain the PCs, so batch effects will likely still be present (though hopefully less pronounced) and must be removed with methods like <a href="https://github.com/LTLA/CppMnnCorrect">MNN correction</a>.</p>
<p>Finally, we can combine these mechanisms to compute rotation vectors from residuals with equal weighting. This gives us the benefits of both approaches as described above. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a826421c677af500db839f8a18a2c39" name="a1a826421c677af500db839f8a18a2c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a826421c677af500db839f8a18a2c39">&#9670;&#160;</a></span>set_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_rank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a248820dc9034a1bafd85a65c2eeca6f4">Defaults::rank</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Number of PCs to compute. This should be no greater than the maximum number of PCs, i.e., the smaller dimension of the input matrix; otherwise, only the maximum number of PCs will be reported in the <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html" title="Container for the PCA results.">Results</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="affd83f857848808000f8a1750c950152" name="affd83f857848808000f8a1750c950152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd83f857848808000f8a1750c950152">&#9670;&#160;</a></span>set_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_scale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>s</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a9dd4b828319c23efbf41857432140fe8">Defaults::scale</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Should genes be scaled to unit variance?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="abbdb8c1a5db29d6db7e9b63b8f47a46a" name="abbdb8c1a5db29d6db7e9b63b8f47a46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdb8c1a5db29d6db7e9b63b8f47a46a">&#9670;&#160;</a></span>set_transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_transpose </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>t</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a21094170e7bad50d62c41953af91ee14">Defaults::transpose</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Should the PC matrix be transposed on output? If <code>true</code>, the output matrix is column-major with cells in the columns, which is compatible with downstream <b>libscran</b> steps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="ac2e92f29f42ab49d2a83d756fae75638" name="ac2e92f29f42ab49d2a83d756fae75638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e92f29f42ab49d2a83d756fae75638">&#9670;&#160;</a></span>set_use_residuals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_use_residuals </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>u</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#aeaf151ac0d14f85b26c1acf16dd2eec5">Defaults::use_residuals</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Whether to compute the rotation vectors from the residuals after centering each batch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="ab3fd66fbbc86c9ec8be6899a75fa463b" name="ab3fd66fbbc86c9ec8be6899a75fa463b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fd66fbbc86c9ec8be6899a75fa463b">&#9670;&#160;</a></span>set_block_weight_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_block_weight_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacescran.html#abcd041d625290609e221552910ae2c34">WeightPolicy</a>&#160;</td>
          <td class="paramname"><em>w</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a309917adfb9497416204fb547db3d9b5">Defaults::block_weight_policy</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Policy to use for weighting batches of different size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="afe01c3b8a4dc06b7e60ae281af2ce992" name="afe01c3b8a4dc06b7e60ae281af2ce992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe01c3b8a4dc06b7e60ae281af2ce992">&#9670;&#160;</a></span>set_variable_block_weight_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_variable_block_weight_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscran_1_1VariableBlockWeightParameters.html">VariableBlockWeightParameters</a>&#160;</td>
          <td class="paramname"><em>v</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#afddd3819171f2d7175b72b27aa3fb54e">Defaults::variable_block_weight_parameters</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Parameters for the variable block weights, see <code><a class="el" href="namespacescran.html#a128f43444ef77988f27ae5b91cef6b13">variable_block_weight()</a></code> for more details. Only used when the block weight policy is set to <code>WeightPolicy::VARIABLE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="a6325469e46f9a4dc9a6969d44cab099d" name="a6325469e46f9a4dc9a6969d44cab099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6325469e46f9a4dc9a6969d44cab099d">&#9670;&#160;</a></span>set_return_rotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_return_rotation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a290139ceca981fae9c7c5f49b6a6f095">Defaults::return_rotation</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Should the rotation matrix be returned in the output?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="af44678f99924f3e0025fb06d88237132" name="af44678f99924f3e0025fb06d88237132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44678f99924f3e0025fb06d88237132">&#9670;&#160;</a></span>set_return_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_return_center </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a4b47e1cdbc323a960c517cc71c9f6a12">Defaults::return_center</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Should the center vector be returned in the output?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="ad68c3d9595aadac26fe358dfe7a66cbd" name="ad68c3d9595aadac26fe358dfe7a66cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68c3d9595aadac26fe358dfe7a66cbd">&#9670;&#160;</a></span>set_return_scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_return_scale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>r</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#aa057739b9f0c851051d2cb1517a7378a">Defaults::return_scale</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Should the scale vector be returned in the output?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="ada6b9bd782acd3f4d202d287b9204200" name="ada6b9bd782acd3f4d202d287b9204200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6b9bd782acd3f4d202d287b9204200">&#9670;&#160;</a></span>set_num_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classscran_1_1MultiBatchPca.html">MultiBatchPca</a> &amp; scran::MultiBatchPca::set_num_threads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em> = <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Defaults.html#a36884dec33d2a7cff6ae01ba793dbdde">Defaults::num_threads</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this <code><a class="el" href="classscran_1_1MultiBatchPca.html" title="Compute PCA after adjusting for differences between batch sizes.">MultiBatchPca</a></code> instance. </dd></dl>

</div>
</div>
<a id="a02198e53fecd46289c648e8cf9ddaf7f" name="a02198e53fecd46289c648e8cf9ddaf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02198e53fecd46289c648e8cf9ddaf7f">&#9670;&#160;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , typename Batch &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html">Results</a> scran::MultiBatchPca::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Batch *&#160;</td>
          <td class="paramname"><em>batch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run the multi-batch PCA on an input gene-by-cell matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type for the data. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Batch</td><td>Integer type for the batch assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to the input matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch</td><td>Pointer to an array of length equal to the number of cells. This should contain a 0-based batch assignment for each cell (i.e., for <code>n</code> batches, batch identities should run from 0 to <code>n-1</code> with at least one entry for each batch.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html" title="Container for the PCA results.">Results</a></code> object containing the PCs and the variance explained. </dd></dl>

</div>
</div>
<a id="af5b552bdcb748db7dbeb70cec718e706" name="af5b552bdcb748db7dbeb70cec718e706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b552bdcb748db7dbeb70cec718e706">&#9670;&#160;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename IDX , typename Batch , typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html">Results</a> scran::MultiBatchPca::run </td>
          <td>(</td>
          <td class="paramtype">const tatami::Matrix&lt; T, IDX &gt; *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Batch *&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X *&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run the multi-batch PCA on an input gene-by-cell matrix after filtering for genes of interest. We typically use the set of highly variable genes from <code>ChooseHVGs</code>, with the aim being to improve computational efficiency and avoid random noise by removing lowly variable genes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type for the data. </td></tr>
    <tr><td class="paramname">IDX</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Batch</td><td>Integer type for the batch assignments </td></tr>
    <tr><td class="paramname">X</td><td>Integer type for the feature filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Pointer to the input matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">batch</td><td>Pointer to an array of length equal to the number of cells. This should contain a 0-based batch assignment for each cell (i.e., for <code>n</code> batches, batch identities should run from 0 to <code>n-1</code> with at least one entry for each batch.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">features</td><td>Pointer to an array of length equal to the number of genes. Each entry treated as a boolean specifying whether the corresponding genes should be used in the PCA.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structscran_1_1MultiBatchPca_1_1Results.html" title="Container for the PCA results.">Results</a></code> object containing the PCs and the variance explained. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>scran/dimensionality_reduction/<a class="el" href="MultiBatchPca_8hpp_source.html">MultiBatchPca.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
